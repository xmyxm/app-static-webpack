/*! 大众点评网 */
(window.webpackJsonp=window.webpackJsonp||[]).push([[1],[function(module,exports,__webpack_require__){eval("__webpack_require__(3)(__webpack_require__(4))\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = window.Zepto;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVwdG8vZGlzdC96ZXB0by5qcz8wOGFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1CQUFPLENBQUMsQ0FBeUYsRUFBRSxtQkFBTyxDQUFDLENBQWlLOztBQUU1UTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvY2hlbnh1YW5mZW5nL215ZGF0YS9hcHAtc3RhdGljLXdlYnBhY2svbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9jaGVueHVhbmZlbmcvbXlkYXRhL2FwcC1zdGF0aWMtd2VicGFjay9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvY2hlbnh1YW5mZW5nL215ZGF0YS9hcHAtc3RhdGljLXdlYnBhY2svbm9kZV9tb2R1bGVzL3plcHRvL2Rpc3QvemVwdG8uanNcIikpXG5cbi8qKiogRVhQT1JUUyBGUk9NIGV4cG9ydHMtbG9hZGVyICoqKi9cbm1vZHVsZS5leHBvcnRzID0gd2luZG93LlplcHRvOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},,,function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ZjJiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("module.exports = \"/* Zepto v1.2.0 - zepto event ajax form ie - zeptojs.com/license */\\n(function(global, factory) {\\n  if (typeof define === 'function' && define.amd)\\n    define(function() { return factory(global) })\\n  else\\n    factory(global)\\n}(this, function(window) {\\n  var Zepto = (function() {\\n  var undefined, key, $, classList, emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice,\\n    document = window.document,\\n    elementDisplay = {}, classCache = {},\\n    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1,'opacity': 1, 'z-index': 1, 'zoom': 1 },\\n    fragmentRE = /^\\\\s*<(\\\\w+|!)[^>]*>/,\\n    singleTagRE = /^<(\\\\w+)\\\\s*\\\\/?>(?:<\\\\/\\\\1>|)$/,\\n    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\\\w:]+)[^>]*)\\\\/>/ig,\\n    rootNodeRE = /^(?:body|html)$/i,\\n    capitalRE = /([A-Z])/g,\\n\\n    // special attributes that should be get/set via method calls\\n    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\\n\\n    adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ],\\n    table = document.createElement('table'),\\n    tableRow = document.createElement('tr'),\\n    containers = {\\n      'tr': document.createElement('tbody'),\\n      'tbody': table, 'thead': table, 'tfoot': table,\\n      'td': tableRow, 'th': tableRow,\\n      '*': document.createElement('div')\\n    },\\n    readyRE = /complete|loaded|interactive/,\\n    simpleSelectorRE = /^[\\\\w-]*$/,\\n    class2type = {},\\n    toString = class2type.toString,\\n    zepto = {},\\n    camelize, uniq,\\n    tempParent = document.createElement('div'),\\n    propMap = {\\n      'tabindex': 'tabIndex',\\n      'readonly': 'readOnly',\\n      'for': 'htmlFor',\\n      'class': 'className',\\n      'maxlength': 'maxLength',\\n      'cellspacing': 'cellSpacing',\\n      'cellpadding': 'cellPadding',\\n      'rowspan': 'rowSpan',\\n      'colspan': 'colSpan',\\n      'usemap': 'useMap',\\n      'frameborder': 'frameBorder',\\n      'contenteditable': 'contentEditable'\\n    },\\n    isArray = Array.isArray ||\\n      function(object){ return object instanceof Array }\\n\\n  zepto.matches = function(element, selector) {\\n    if (!selector || !element || element.nodeType !== 1) return false\\n    var matchesSelector = element.matches || element.webkitMatchesSelector ||\\n                          element.mozMatchesSelector || element.oMatchesSelector ||\\n                          element.matchesSelector\\n    if (matchesSelector) return matchesSelector.call(element, selector)\\n    // fall back to performing a selector:\\n    var match, parent = element.parentNode, temp = !parent\\n    if (temp) (parent = tempParent).appendChild(element)\\n    match = ~zepto.qsa(parent, selector).indexOf(element)\\n    temp && tempParent.removeChild(element)\\n    return match\\n  }\\n\\n  function type(obj) {\\n    return obj == null ? String(obj) :\\n      class2type[toString.call(obj)] || \\\"object\\\"\\n  }\\n\\n  function isFunction(value) { return type(value) == \\\"function\\\" }\\n  function isWindow(obj)     { return obj != null && obj == obj.window }\\n  function isDocument(obj)   { return obj != null && obj.nodeType == obj.DOCUMENT_NODE }\\n  function isObject(obj)     { return type(obj) == \\\"object\\\" }\\n  function isPlainObject(obj) {\\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype\\n  }\\n\\n  function likeArray(obj) {\\n    var length = !!obj && 'length' in obj && obj.length,\\n      type = $.type(obj)\\n\\n    return 'function' != type && !isWindow(obj) && (\\n      'array' == type || length === 0 ||\\n        (typeof length == 'number' && length > 0 && (length - 1) in obj)\\n    )\\n  }\\n\\n  function compact(array) { return filter.call(array, function(item){ return item != null }) }\\n  function flatten(array) { return array.length > 0 ? $.fn.concat.apply([], array) : array }\\n  camelize = function(str){ return str.replace(/-+(.)?/g, function(match, chr){ return chr ? chr.toUpperCase() : '' }) }\\n  function dasherize(str) {\\n    return str.replace(/::/g, '/')\\n           .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')\\n           .replace(/([a-z\\\\d])([A-Z])/g, '$1_$2')\\n           .replace(/_/g, '-')\\n           .toLowerCase()\\n  }\\n  uniq = function(array){ return filter.call(array, function(item, idx){ return array.indexOf(item) == idx }) }\\n\\n  function classRE(name) {\\n    return name in classCache ?\\n      classCache[name] : (classCache[name] = new RegExp('(^|\\\\\\\\s)' + name + '(\\\\\\\\s|$)'))\\n  }\\n\\n  function maybeAddPx(name, value) {\\n    return (typeof value == \\\"number\\\" && !cssNumber[dasherize(name)]) ? value + \\\"px\\\" : value\\n  }\\n\\n  function defaultDisplay(nodeName) {\\n    var element, display\\n    if (!elementDisplay[nodeName]) {\\n      element = document.createElement(nodeName)\\n      document.body.appendChild(element)\\n      display = getComputedStyle(element, '').getPropertyValue(\\\"display\\\")\\n      element.parentNode.removeChild(element)\\n      display == \\\"none\\\" && (display = \\\"block\\\")\\n      elementDisplay[nodeName] = display\\n    }\\n    return elementDisplay[nodeName]\\n  }\\n\\n  function children(element) {\\n    return 'children' in element ?\\n      slice.call(element.children) :\\n      $.map(element.childNodes, function(node){ if (node.nodeType == 1) return node })\\n  }\\n\\n  function Z(dom, selector) {\\n    var i, len = dom ? dom.length : 0\\n    for (i = 0; i < len; i++) this[i] = dom[i]\\n    this.length = len\\n    this.selector = selector || ''\\n  }\\n\\n  // `$.zepto.fragment` takes a html string and an optional tag name\\n  // to generate DOM nodes from the given html string.\\n  // The generated DOM nodes are returned as an array.\\n  // This function can be overridden in plugins for example to make\\n  // it compatible with browsers that don't support the DOM fully.\\n  zepto.fragment = function(html, name, properties) {\\n    var dom, nodes, container\\n\\n    // A special case optimization for a single tag\\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1))\\n\\n    if (!dom) {\\n      if (html.replace) html = html.replace(tagExpanderRE, \\\"<$1></$2>\\\")\\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1\\n      if (!(name in containers)) name = '*'\\n\\n      container = containers[name]\\n      container.innerHTML = '' + html\\n      dom = $.each(slice.call(container.childNodes), function(){\\n        container.removeChild(this)\\n      })\\n    }\\n\\n    if (isPlainObject(properties)) {\\n      nodes = $(dom)\\n      $.each(properties, function(key, value) {\\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value)\\n        else nodes.attr(key, value)\\n      })\\n    }\\n\\n    return dom\\n  }\\n\\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\\n  // to the array. This method can be overridden in plugins.\\n  zepto.Z = function(dom, selector) {\\n    return new Z(dom, selector)\\n  }\\n\\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\\n  // collection. This method can be overridden in plugins.\\n  zepto.isZ = function(object) {\\n    return object instanceof zepto.Z\\n  }\\n\\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\\n  // takes a CSS selector and an optional context (and handles various\\n  // special cases).\\n  // This method can be overridden in plugins.\\n  zepto.init = function(selector, context) {\\n    var dom\\n    // If nothing given, return an empty Zepto collection\\n    if (!selector) return zepto.Z()\\n    // Optimize for string selectors\\n    else if (typeof selector == 'string') {\\n      selector = selector.trim()\\n      // If it's a html fragment, create nodes from it\\n      // Note: In both Chrome 21 and Firefox 15, DOM error 12\\n      // is thrown if the fragment doesn't begin with <\\n      if (selector[0] == '<' && fragmentRE.test(selector))\\n        dom = zepto.fragment(selector, RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // If it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // If a function is given, call it when the DOM is ready\\n    else if (isFunction(selector)) return $(document).ready(selector)\\n    // If a Zepto collection is given, just return it\\n    else if (zepto.isZ(selector)) return selector\\n    else {\\n      // normalize array if an array of nodes is given\\n      if (isArray(selector)) dom = compact(selector)\\n      // Wrap DOM nodes.\\n      else if (isObject(selector))\\n        dom = [selector], selector = null\\n      // If it's a html fragment, create nodes from it\\n      else if (fragmentRE.test(selector))\\n        dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null\\n      // If there's a context, create a collection on that context first, and select\\n      // nodes from there\\n      else if (context !== undefined) return $(context).find(selector)\\n      // And last but no least, if it's a CSS selector, use it to select nodes.\\n      else dom = zepto.qsa(document, selector)\\n    }\\n    // create a new Zepto collection from the nodes found\\n    return zepto.Z(dom, selector)\\n  }\\n\\n  // `$` will be the base `Zepto` object. When calling this\\n  // function just call `$.zepto.init, which makes the implementation\\n  // details of selecting nodes and creating Zepto collections\\n  // patchable in plugins.\\n  $ = function(selector, context){\\n    return zepto.init(selector, context)\\n  }\\n\\n  function extend(target, source, deep) {\\n    for (key in source)\\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\\n        if (isPlainObject(source[key]) && !isPlainObject(target[key]))\\n          target[key] = {}\\n        if (isArray(source[key]) && !isArray(target[key]))\\n          target[key] = []\\n        extend(target[key], source[key], deep)\\n      }\\n      else if (source[key] !== undefined) target[key] = source[key]\\n  }\\n\\n  // Copy all but undefined properties from one or more\\n  // objects to the `target` object.\\n  $.extend = function(target){\\n    var deep, args = slice.call(arguments, 1)\\n    if (typeof target == 'boolean') {\\n      deep = target\\n      target = args.shift()\\n    }\\n    args.forEach(function(arg){ extend(target, arg, deep) })\\n    return target\\n  }\\n\\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\\n  // This method can be overridden in plugins.\\n  zepto.qsa = function(element, selector){\\n    var found,\\n        maybeID = selector[0] == '#',\\n        maybeClass = !maybeID && selector[0] == '.',\\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked\\n        isSimple = simpleSelectorRE.test(nameOnly)\\n    return (element.getElementById && isSimple && maybeID) ? // Safari DocumentFragment doesn't have getElementById\\n      ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :\\n      (element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11) ? [] :\\n      slice.call(\\n        isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName\\n          maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\\n          element.getElementsByTagName(selector) : // Or a tag\\n          element.querySelectorAll(selector) // Or it's not simple, and we need to query all\\n      )\\n  }\\n\\n  function filtered(nodes, selector) {\\n    return selector == null ? $(nodes) : $(nodes).filter(selector)\\n  }\\n\\n  $.contains = document.documentElement.contains ?\\n    function(parent, node) {\\n      return parent !== node && parent.contains(node)\\n    } :\\n    function(parent, node) {\\n      while (node && (node = node.parentNode))\\n        if (node === parent) return true\\n      return false\\n    }\\n\\n  function funcArg(context, arg, idx, payload) {\\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg\\n  }\\n\\n  function setAttribute(node, name, value) {\\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value)\\n  }\\n\\n  // access className property while respecting SVGAnimatedString\\n  function className(node, value){\\n    var klass = node.className || '',\\n        svg   = klass && klass.baseVal !== undefined\\n\\n    if (value === undefined) return svg ? klass.baseVal : klass\\n    svg ? (klass.baseVal = value) : (node.className = value)\\n  }\\n\\n  // \\\"true\\\"  => true\\n  // \\\"false\\\" => false\\n  // \\\"null\\\"  => null\\n  // \\\"42\\\"    => 42\\n  // \\\"42.5\\\"  => 42.5\\n  // \\\"08\\\"    => \\\"08\\\"\\n  // JSON    => parse if valid\\n  // String  => self\\n  function deserializeValue(value) {\\n    try {\\n      return value ?\\n        value == \\\"true\\\" ||\\n        ( value == \\\"false\\\" ? false :\\n          value == \\\"null\\\" ? null :\\n          +value + \\\"\\\" == value ? +value :\\n          /^[\\\\[\\\\{]/.test(value) ? $.parseJSON(value) :\\n          value )\\n        : value\\n    } catch(e) {\\n      return value\\n    }\\n  }\\n\\n  $.type = type\\n  $.isFunction = isFunction\\n  $.isWindow = isWindow\\n  $.isArray = isArray\\n  $.isPlainObject = isPlainObject\\n\\n  $.isEmptyObject = function(obj) {\\n    var name\\n    for (name in obj) return false\\n    return true\\n  }\\n\\n  $.isNumeric = function(val) {\\n    var num = Number(val), type = typeof val\\n    return val != null && type != 'boolean' &&\\n      (type != 'string' || val.length) &&\\n      !isNaN(num) && isFinite(num) || false\\n  }\\n\\n  $.inArray = function(elem, array, i){\\n    return emptyArray.indexOf.call(array, elem, i)\\n  }\\n\\n  $.camelCase = camelize\\n  $.trim = function(str) {\\n    return str == null ? \\\"\\\" : String.prototype.trim.call(str)\\n  }\\n\\n  // plugin compatibility\\n  $.uuid = 0\\n  $.support = { }\\n  $.expr = { }\\n  $.noop = function() {}\\n\\n  $.map = function(elements, callback){\\n    var value, values = [], i, key\\n    if (likeArray(elements))\\n      for (i = 0; i < elements.length; i++) {\\n        value = callback(elements[i], i)\\n        if (value != null) values.push(value)\\n      }\\n    else\\n      for (key in elements) {\\n        value = callback(elements[key], key)\\n        if (value != null) values.push(value)\\n      }\\n    return flatten(values)\\n  }\\n\\n  $.each = function(elements, callback){\\n    var i, key\\n    if (likeArray(elements)) {\\n      for (i = 0; i < elements.length; i++)\\n        if (callback.call(elements[i], i, elements[i]) === false) return elements\\n    } else {\\n      for (key in elements)\\n        if (callback.call(elements[key], key, elements[key]) === false) return elements\\n    }\\n\\n    return elements\\n  }\\n\\n  $.grep = function(elements, callback){\\n    return filter.call(elements, callback)\\n  }\\n\\n  if (window.JSON) $.parseJSON = JSON.parse\\n\\n  // Populate the class2type map\\n  $.each(\\\"Boolean Number String Function Array Date RegExp Object Error\\\".split(\\\" \\\"), function(i, name) {\\n    class2type[ \\\"[object \\\" + name + \\\"]\\\" ] = name.toLowerCase()\\n  })\\n\\n  // Define methods that will be available on all\\n  // Zepto collections\\n  $.fn = {\\n    constructor: zepto.Z,\\n    length: 0,\\n\\n    // Because a collection acts like an array\\n    // copy over these useful array functions.\\n    forEach: emptyArray.forEach,\\n    reduce: emptyArray.reduce,\\n    push: emptyArray.push,\\n    sort: emptyArray.sort,\\n    splice: emptyArray.splice,\\n    indexOf: emptyArray.indexOf,\\n    concat: function(){\\n      var i, value, args = []\\n      for (i = 0; i < arguments.length; i++) {\\n        value = arguments[i]\\n        args[i] = zepto.isZ(value) ? value.toArray() : value\\n      }\\n      return concat.apply(zepto.isZ(this) ? this.toArray() : this, args)\\n    },\\n\\n    // `map` and `slice` in the jQuery API work differently\\n    // from their array counterparts\\n    map: function(fn){\\n      return $($.map(this, function(el, i){ return fn.call(el, i, el) }))\\n    },\\n    slice: function(){\\n      return $(slice.apply(this, arguments))\\n    },\\n\\n    ready: function(callback){\\n      // need to check if document.body exists for IE as that browser reports\\n      // document ready when it hasn't yet created the body element\\n      if (readyRE.test(document.readyState) && document.body) callback($)\\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\\n      return this\\n    },\\n    get: function(idx){\\n      return idx === undefined ? slice.call(this) : this[idx >= 0 ? idx : idx + this.length]\\n    },\\n    toArray: function(){ return this.get() },\\n    size: function(){\\n      return this.length\\n    },\\n    remove: function(){\\n      return this.each(function(){\\n        if (this.parentNode != null)\\n          this.parentNode.removeChild(this)\\n      })\\n    },\\n    each: function(callback){\\n      emptyArray.every.call(this, function(el, idx){\\n        return callback.call(el, idx, el) !== false\\n      })\\n      return this\\n    },\\n    filter: function(selector){\\n      if (isFunction(selector)) return this.not(this.not(selector))\\n      return $(filter.call(this, function(element){\\n        return zepto.matches(element, selector)\\n      }))\\n    },\\n    add: function(selector,context){\\n      return $(uniq(this.concat($(selector,context))))\\n    },\\n    is: function(selector){\\n      return this.length > 0 && zepto.matches(this[0], selector)\\n    },\\n    not: function(selector){\\n      var nodes=[]\\n      if (isFunction(selector) && selector.call !== undefined)\\n        this.each(function(idx){\\n          if (!selector.call(this,idx)) nodes.push(this)\\n        })\\n      else {\\n        var excludes = typeof selector == 'string' ? this.filter(selector) :\\n          (likeArray(selector) && isFunction(selector.item)) ? slice.call(selector) : $(selector)\\n        this.forEach(function(el){\\n          if (excludes.indexOf(el) < 0) nodes.push(el)\\n        })\\n      }\\n      return $(nodes)\\n    },\\n    has: function(selector){\\n      return this.filter(function(){\\n        return isObject(selector) ?\\n          $.contains(this, selector) :\\n          $(this).find(selector).size()\\n      })\\n    },\\n    eq: function(idx){\\n      return idx === -1 ? this.slice(idx) : this.slice(idx, + idx + 1)\\n    },\\n    first: function(){\\n      var el = this[0]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    last: function(){\\n      var el = this[this.length - 1]\\n      return el && !isObject(el) ? el : $(el)\\n    },\\n    find: function(selector){\\n      var result, $this = this\\n      if (!selector) result = $()\\n      else if (typeof selector == 'object')\\n        result = $(selector).filter(function(){\\n          var node = this\\n          return emptyArray.some.call($this, function(parent){\\n            return $.contains(parent, node)\\n          })\\n        })\\n      else if (this.length == 1) result = $(zepto.qsa(this[0], selector))\\n      else result = this.map(function(){ return zepto.qsa(this, selector) })\\n      return result\\n    },\\n    closest: function(selector, context){\\n      var nodes = [], collection = typeof selector == 'object' && $(selector)\\n      this.each(function(_, node){\\n        while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector)))\\n          node = node !== context && !isDocument(node) && node.parentNode\\n        if (node && nodes.indexOf(node) < 0) nodes.push(node)\\n      })\\n      return $(nodes)\\n    },\\n    parents: function(selector){\\n      var ancestors = [], nodes = this\\n      while (nodes.length > 0)\\n        nodes = $.map(nodes, function(node){\\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\\n            ancestors.push(node)\\n            return node\\n          }\\n        })\\n      return filtered(ancestors, selector)\\n    },\\n    parent: function(selector){\\n      return filtered(uniq(this.pluck('parentNode')), selector)\\n    },\\n    children: function(selector){\\n      return filtered(this.map(function(){ return children(this) }), selector)\\n    },\\n    contents: function() {\\n      return this.map(function() { return this.contentDocument || slice.call(this.childNodes) })\\n    },\\n    siblings: function(selector){\\n      return filtered(this.map(function(i, el){\\n        return filter.call(children(el.parentNode), function(child){ return child!==el })\\n      }), selector)\\n    },\\n    empty: function(){\\n      return this.each(function(){ this.innerHTML = '' })\\n    },\\n    // `pluck` is borrowed from Prototype.js\\n    pluck: function(property){\\n      return $.map(this, function(el){ return el[property] })\\n    },\\n    show: function(){\\n      return this.each(function(){\\n        this.style.display == \\\"none\\\" && (this.style.display = '')\\n        if (getComputedStyle(this, '').getPropertyValue(\\\"display\\\") == \\\"none\\\")\\n          this.style.display = defaultDisplay(this.nodeName)\\n      })\\n    },\\n    replaceWith: function(newContent){\\n      return this.before(newContent).remove()\\n    },\\n    wrap: function(structure){\\n      var func = isFunction(structure)\\n      if (this[0] && !func)\\n        var dom   = $(structure).get(0),\\n            clone = dom.parentNode || this.length > 1\\n\\n      return this.each(function(index){\\n        $(this).wrapAll(\\n          func ? structure.call(this, index) :\\n            clone ? dom.cloneNode(true) : dom\\n        )\\n      })\\n    },\\n    wrapAll: function(structure){\\n      if (this[0]) {\\n        $(this[0]).before(structure = $(structure))\\n        var children\\n        // drill down to the inmost element\\n        while ((children = structure.children()).length) structure = children.first()\\n        $(structure).append(this)\\n      }\\n      return this\\n    },\\n    wrapInner: function(structure){\\n      var func = isFunction(structure)\\n      return this.each(function(index){\\n        var self = $(this), contents = self.contents(),\\n            dom  = func ? structure.call(this, index) : structure\\n        contents.length ? contents.wrapAll(dom) : self.append(dom)\\n      })\\n    },\\n    unwrap: function(){\\n      this.parent().each(function(){\\n        $(this).replaceWith($(this).children())\\n      })\\n      return this\\n    },\\n    clone: function(){\\n      return this.map(function(){ return this.cloneNode(true) })\\n    },\\n    hide: function(){\\n      return this.css(\\\"display\\\", \\\"none\\\")\\n    },\\n    toggle: function(setting){\\n      return this.each(function(){\\n        var el = $(this)\\n        ;(setting === undefined ? el.css(\\\"display\\\") == \\\"none\\\" : setting) ? el.show() : el.hide()\\n      })\\n    },\\n    prev: function(selector){ return $(this.pluck('previousElementSibling')).filter(selector || '*') },\\n    next: function(selector){ return $(this.pluck('nextElementSibling')).filter(selector || '*') },\\n    html: function(html){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var originHtml = this.innerHTML\\n          $(this).empty().append( funcArg(this, html, idx, originHtml) )\\n        }) :\\n        (0 in this ? this[0].innerHTML : null)\\n    },\\n    text: function(text){\\n      return 0 in arguments ?\\n        this.each(function(idx){\\n          var newText = funcArg(this, text, idx, this.textContent)\\n          this.textContent = newText == null ? '' : ''+newText\\n        }) :\\n        (0 in this ? this.pluck('textContent').join(\\\"\\\") : null)\\n    },\\n    attr: function(name, value){\\n      var result\\n      return (typeof name == 'string' && !(1 in arguments)) ?\\n        (0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined) :\\n        this.each(function(idx){\\n          if (this.nodeType !== 1) return\\n          if (isObject(name)) for (key in name) setAttribute(this, key, name[key])\\n          else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)))\\n        })\\n    },\\n    removeAttr: function(name){\\n      return this.each(function(){ this.nodeType === 1 && name.split(' ').forEach(function(attribute){\\n        setAttribute(this, attribute)\\n      }, this)})\\n    },\\n    prop: function(name, value){\\n      name = propMap[name] || name\\n      return (1 in arguments) ?\\n        this.each(function(idx){\\n          this[name] = funcArg(this, value, idx, this[name])\\n        }) :\\n        (this[0] && this[0][name])\\n    },\\n    removeProp: function(name){\\n      name = propMap[name] || name\\n      return this.each(function(){ delete this[name] })\\n    },\\n    data: function(name, value){\\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase()\\n\\n      var data = (1 in arguments) ?\\n        this.attr(attrName, value) :\\n        this.attr(attrName)\\n\\n      return data !== null ? deserializeValue(data) : undefined\\n    },\\n    val: function(value){\\n      if (0 in arguments) {\\n        if (value == null) value = \\\"\\\"\\n        return this.each(function(idx){\\n          this.value = funcArg(this, value, idx, this.value)\\n        })\\n      } else {\\n        return this[0] && (this[0].multiple ?\\n           $(this[0]).find('option').filter(function(){ return this.selected }).pluck('value') :\\n           this[0].value)\\n      }\\n    },\\n    offset: function(coordinates){\\n      if (coordinates) return this.each(function(index){\\n        var $this = $(this),\\n            coords = funcArg(this, coordinates, index, $this.offset()),\\n            parentOffset = $this.offsetParent().offset(),\\n            props = {\\n              top:  coords.top  - parentOffset.top,\\n              left: coords.left - parentOffset.left\\n            }\\n\\n        if ($this.css('position') == 'static') props['position'] = 'relative'\\n        $this.css(props)\\n      })\\n      if (!this.length) return null\\n      if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0]))\\n        return {top: 0, left: 0}\\n      var obj = this[0].getBoundingClientRect()\\n      return {\\n        left: obj.left + window.pageXOffset,\\n        top: obj.top + window.pageYOffset,\\n        width: Math.round(obj.width),\\n        height: Math.round(obj.height)\\n      }\\n    },\\n    css: function(property, value){\\n      if (arguments.length < 2) {\\n        var element = this[0]\\n        if (typeof property == 'string') {\\n          if (!element) return\\n          return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property)\\n        } else if (isArray(property)) {\\n          if (!element) return\\n          var props = {}\\n          var computedStyle = getComputedStyle(element, '')\\n          $.each(property, function(_, prop){\\n            props[prop] = (element.style[camelize(prop)] || computedStyle.getPropertyValue(prop))\\n          })\\n          return props\\n        }\\n      }\\n\\n      var css = ''\\n      if (type(property) == 'string') {\\n        if (!value && value !== 0)\\n          this.each(function(){ this.style.removeProperty(dasherize(property)) })\\n        else\\n          css = dasherize(property) + \\\":\\\" + maybeAddPx(property, value)\\n      } else {\\n        for (key in property)\\n          if (!property[key] && property[key] !== 0)\\n            this.each(function(){ this.style.removeProperty(dasherize(key)) })\\n          else\\n            css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\\n      }\\n\\n      return this.each(function(){ this.style.cssText += ';' + css })\\n    },\\n    index: function(element){\\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0])\\n    },\\n    hasClass: function(name){\\n      if (!name) return false\\n      return emptyArray.some.call(this, function(el){\\n        return this.test(className(el))\\n      }, classRE(name))\\n    },\\n    addClass: function(name){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        classList = []\\n        var cls = className(this), newName = funcArg(this, name, idx, cls)\\n        newName.split(/\\\\s+/g).forEach(function(klass){\\n          if (!$(this).hasClass(klass)) classList.push(klass)\\n        }, this)\\n        classList.length && className(this, cls + (cls ? \\\" \\\" : \\\"\\\") + classList.join(\\\" \\\"))\\n      })\\n    },\\n    removeClass: function(name){\\n      return this.each(function(idx){\\n        if (!('className' in this)) return\\n        if (name === undefined) return className(this, '')\\n        classList = className(this)\\n        funcArg(this, name, idx, classList).split(/\\\\s+/g).forEach(function(klass){\\n          classList = classList.replace(classRE(klass), \\\" \\\")\\n        })\\n        className(this, classList.trim())\\n      })\\n    },\\n    toggleClass: function(name, when){\\n      if (!name) return this\\n      return this.each(function(idx){\\n        var $this = $(this), names = funcArg(this, name, idx, className(this))\\n        names.split(/\\\\s+/g).forEach(function(klass){\\n          (when === undefined ? !$this.hasClass(klass) : when) ?\\n            $this.addClass(klass) : $this.removeClass(klass)\\n        })\\n      })\\n    },\\n    scrollTop: function(value){\\n      if (!this.length) return\\n      var hasScrollTop = 'scrollTop' in this[0]\\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset\\n      return this.each(hasScrollTop ?\\n        function(){ this.scrollTop = value } :\\n        function(){ this.scrollTo(this.scrollX, value) })\\n    },\\n    scrollLeft: function(value){\\n      if (!this.length) return\\n      var hasScrollLeft = 'scrollLeft' in this[0]\\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset\\n      return this.each(hasScrollLeft ?\\n        function(){ this.scrollLeft = value } :\\n        function(){ this.scrollTo(value, this.scrollY) })\\n    },\\n    position: function() {\\n      if (!this.length) return\\n\\n      var elem = this[0],\\n        // Get *real* offsetParent\\n        offsetParent = this.offsetParent(),\\n        // Get correct offsets\\n        offset       = this.offset(),\\n        parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset()\\n\\n      // Subtract element margins\\n      // note: when an element has margin: auto the offsetLeft and marginLeft\\n      // are the same in Safari causing offset.left to incorrectly be 0\\n      offset.top  -= parseFloat( $(elem).css('margin-top') ) || 0\\n      offset.left -= parseFloat( $(elem).css('margin-left') ) || 0\\n\\n      // Add offsetParent borders\\n      parentOffset.top  += parseFloat( $(offsetParent[0]).css('border-top-width') ) || 0\\n      parentOffset.left += parseFloat( $(offsetParent[0]).css('border-left-width') ) || 0\\n\\n      // Subtract the two offsets\\n      return {\\n        top:  offset.top  - parentOffset.top,\\n        left: offset.left - parentOffset.left\\n      }\\n    },\\n    offsetParent: function() {\\n      return this.map(function(){\\n        var parent = this.offsetParent || document.body\\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\\\"position\\\") == \\\"static\\\")\\n          parent = parent.offsetParent\\n        return parent\\n      })\\n    }\\n  }\\n\\n  // for now\\n  $.fn.detach = $.fn.remove\\n\\n  // Generate the `width` and `height` functions\\n  ;['width', 'height'].forEach(function(dimension){\\n    var dimensionProperty =\\n      dimension.replace(/./, function(m){ return m[0].toUpperCase() })\\n\\n    $.fn[dimension] = function(value){\\n      var offset, el = this[0]\\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] :\\n        isDocument(el) ? el.documentElement['scroll' + dimensionProperty] :\\n        (offset = this.offset()) && offset[dimension]\\n      else return this.each(function(idx){\\n        el = $(this)\\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()))\\n      })\\n    }\\n  })\\n\\n  function traverseNode(node, fun) {\\n    fun(node)\\n    for (var i = 0, len = node.childNodes.length; i < len; i++)\\n      traverseNode(node.childNodes[i], fun)\\n  }\\n\\n  // Generate the `after`, `prepend`, `before`, `append`,\\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\\n  adjacencyOperators.forEach(function(operator, operatorIndex) {\\n    var inside = operatorIndex % 2 //=> prepend, append\\n\\n    $.fn[operator] = function(){\\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\\n      var argType, nodes = $.map(arguments, function(arg) {\\n            var arr = []\\n            argType = type(arg)\\n            if (argType == \\\"array\\\") {\\n              arg.forEach(function(el) {\\n                if (el.nodeType !== undefined) return arr.push(el)\\n                else if ($.zepto.isZ(el)) return arr = arr.concat(el.get())\\n                arr = arr.concat(zepto.fragment(el))\\n              })\\n              return arr\\n            }\\n            return argType == \\\"object\\\" || arg == null ?\\n              arg : zepto.fragment(arg)\\n          }),\\n          parent, copyByClone = this.length > 1\\n      if (nodes.length < 1) return this\\n\\n      return this.each(function(_, target){\\n        parent = inside ? target : target.parentNode\\n\\n        // convert all methods to a \\\"before\\\" operation\\n        target = operatorIndex == 0 ? target.nextSibling :\\n                 operatorIndex == 1 ? target.firstChild :\\n                 operatorIndex == 2 ? target :\\n                 null\\n\\n        var parentInDocument = $.contains(document.documentElement, parent)\\n\\n        nodes.forEach(function(node){\\n          if (copyByClone) node = node.cloneNode(true)\\n          else if (!parent) return $(node).remove()\\n\\n          parent.insertBefore(node, target)\\n          if (parentInDocument) traverseNode(node, function(el){\\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' &&\\n               (!el.type || el.type === 'text/javascript') && !el.src){\\n              var target = el.ownerDocument ? el.ownerDocument.defaultView : window\\n              target['eval'].call(target, el.innerHTML)\\n            }\\n          })\\n        })\\n      })\\n    }\\n\\n    // after    => insertAfter\\n    // prepend  => prependTo\\n    // before   => insertBefore\\n    // append   => appendTo\\n    $.fn[inside ? operator+'To' : 'insert'+(operatorIndex ? 'Before' : 'After')] = function(html){\\n      $(html)[operator](this)\\n      return this\\n    }\\n  })\\n\\n  zepto.Z.prototype = Z.prototype = $.fn\\n\\n  // Export internal API functions in the `$.zepto` namespace\\n  zepto.uniq = uniq\\n  zepto.deserializeValue = deserializeValue\\n  $.zepto = zepto\\n\\n  return $\\n})()\\n\\nwindow.Zepto = Zepto\\nwindow.$ === undefined && (window.$ = Zepto)\\n\\n;(function($){\\n  var _zid = 1, undefined,\\n      slice = Array.prototype.slice,\\n      isFunction = $.isFunction,\\n      isString = function(obj){ return typeof obj == 'string' },\\n      handlers = {},\\n      specialEvents={},\\n      focusinSupported = 'onfocusin' in window,\\n      focus = { focus: 'focusin', blur: 'focusout' },\\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' }\\n\\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents'\\n\\n  function zid(element) {\\n    return element._zid || (element._zid = _zid++)\\n  }\\n  function findHandlers(element, event, fn, selector) {\\n    event = parse(event)\\n    if (event.ns) var matcher = matcherFor(event.ns)\\n    return (handlers[zid(element)] || []).filter(function(handler) {\\n      return handler\\n        && (!event.e  || handler.e == event.e)\\n        && (!event.ns || matcher.test(handler.ns))\\n        && (!fn       || zid(handler.fn) === zid(fn))\\n        && (!selector || handler.sel == selector)\\n    })\\n  }\\n  function parse(event) {\\n    var parts = ('' + event).split('.')\\n    return {e: parts[0], ns: parts.slice(1).sort().join(' ')}\\n  }\\n  function matcherFor(ns) {\\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)')\\n  }\\n\\n  function eventCapture(handler, captureSetting) {\\n    return handler.del &&\\n      (!focusinSupported && (handler.e in focus)) ||\\n      !!captureSetting\\n  }\\n\\n  function realEvent(type) {\\n    return hover[type] || (focusinSupported && focus[type]) || type\\n  }\\n\\n  function add(element, events, fn, data, selector, delegator, capture){\\n    var id = zid(element), set = (handlers[id] || (handlers[id] = []))\\n    events.split(/\\\\s/).forEach(function(event){\\n      if (event == 'ready') return $(document).ready(fn)\\n      var handler   = parse(event)\\n      handler.fn    = fn\\n      handler.sel   = selector\\n      // emulate mouseenter, mouseleave\\n      if (handler.e in hover) fn = function(e){\\n        var related = e.relatedTarget\\n        if (!related || (related !== this && !$.contains(this, related)))\\n          return handler.fn.apply(this, arguments)\\n      }\\n      handler.del   = delegator\\n      var callback  = delegator || fn\\n      handler.proxy = function(e){\\n        e = compatible(e)\\n        if (e.isImmediatePropagationStopped()) return\\n        e.data = data\\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args))\\n        if (result === false) e.preventDefault(), e.stopPropagation()\\n        return result\\n      }\\n      handler.i = set.length\\n      set.push(handler)\\n      if ('addEventListener' in element)\\n        element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n    })\\n  }\\n  function remove(element, events, fn, selector, capture){\\n    var id = zid(element)\\n    ;(events || '').split(/\\\\s/).forEach(function(event){\\n      findHandlers(element, event, fn, selector).forEach(function(handler){\\n        delete handlers[id][handler.i]\\n      if ('removeEventListener' in element)\\n        element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture))\\n      })\\n    })\\n  }\\n\\n  $.event = { add: add, remove: remove }\\n\\n  $.proxy = function(fn, context) {\\n    var args = (2 in arguments) && slice.call(arguments, 2)\\n    if (isFunction(fn)) {\\n      var proxyFn = function(){ return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments) }\\n      proxyFn._zid = zid(fn)\\n      return proxyFn\\n    } else if (isString(context)) {\\n      if (args) {\\n        args.unshift(fn[context], fn)\\n        return $.proxy.apply(null, args)\\n      } else {\\n        return $.proxy(fn[context], fn)\\n      }\\n    } else {\\n      throw new TypeError(\\\"expected function\\\")\\n    }\\n  }\\n\\n  $.fn.bind = function(event, data, callback){\\n    return this.on(event, data, callback)\\n  }\\n  $.fn.unbind = function(event, callback){\\n    return this.off(event, callback)\\n  }\\n  $.fn.one = function(event, selector, data, callback){\\n    return this.on(event, selector, data, callback, 1)\\n  }\\n\\n  var returnTrue = function(){return true},\\n      returnFalse = function(){return false},\\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,\\n      eventMethods = {\\n        preventDefault: 'isDefaultPrevented',\\n        stopImmediatePropagation: 'isImmediatePropagationStopped',\\n        stopPropagation: 'isPropagationStopped'\\n      }\\n\\n  function compatible(event, source) {\\n    if (source || !event.isDefaultPrevented) {\\n      source || (source = event)\\n\\n      $.each(eventMethods, function(name, predicate) {\\n        var sourceMethod = source[name]\\n        event[name] = function(){\\n          this[predicate] = returnTrue\\n          return sourceMethod && sourceMethod.apply(source, arguments)\\n        }\\n        event[predicate] = returnFalse\\n      })\\n\\n      event.timeStamp || (event.timeStamp = Date.now())\\n\\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented :\\n          'returnValue' in source ? source.returnValue === false :\\n          source.getPreventDefault && source.getPreventDefault())\\n        event.isDefaultPrevented = returnTrue\\n    }\\n    return event\\n  }\\n\\n  function createProxy(event) {\\n    var key, proxy = { originalEvent: event }\\n    for (key in event)\\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key]\\n\\n    return compatible(proxy, event)\\n  }\\n\\n  $.fn.delegate = function(selector, event, callback){\\n    return this.on(event, selector, callback)\\n  }\\n  $.fn.undelegate = function(selector, event, callback){\\n    return this.off(event, selector, callback)\\n  }\\n\\n  $.fn.live = function(event, callback){\\n    $(document.body).delegate(this.selector, event, callback)\\n    return this\\n  }\\n  $.fn.die = function(event, callback){\\n    $(document.body).undelegate(this.selector, event, callback)\\n    return this\\n  }\\n\\n  $.fn.on = function(event, selector, data, callback, one){\\n    var autoRemove, delegator, $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.on(type, selector, data, fn, one)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = data, data = selector, selector = undefined\\n    if (callback === undefined || data === false)\\n      callback = data, data = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(_, element){\\n      if (one) autoRemove = function(e){\\n        remove(element, e.type, callback)\\n        return callback.apply(this, arguments)\\n      }\\n\\n      if (selector) delegator = function(e){\\n        var evt, match = $(e.target).closest(selector, element).get(0)\\n        if (match && match !== element) {\\n          evt = $.extend(createProxy(e), {currentTarget: match, liveFired: element})\\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)))\\n        }\\n      }\\n\\n      add(element, event, callback, data, selector, delegator || autoRemove)\\n    })\\n  }\\n  $.fn.off = function(event, selector, callback){\\n    var $this = this\\n    if (event && !isString(event)) {\\n      $.each(event, function(type, fn){\\n        $this.off(type, selector, fn)\\n      })\\n      return $this\\n    }\\n\\n    if (!isString(selector) && !isFunction(callback) && callback !== false)\\n      callback = selector, selector = undefined\\n\\n    if (callback === false) callback = returnFalse\\n\\n    return $this.each(function(){\\n      remove(this, event, callback, selector)\\n    })\\n  }\\n\\n  $.fn.trigger = function(event, args){\\n    event = (isString(event) || $.isPlainObject(event)) ? $.Event(event) : compatible(event)\\n    event._args = args\\n    return this.each(function(){\\n      // handle focus(), blur() by calling them directly\\n      if (event.type in focus && typeof this[event.type] == \\\"function\\\") this[event.type]()\\n      // items in the collection might not be DOM elements\\n      else if ('dispatchEvent' in this) this.dispatchEvent(event)\\n      else $(this).triggerHandler(event, args)\\n    })\\n  }\\n\\n  // triggers event handlers on current element just as if an event occurred,\\n  // doesn't trigger an actual event, doesn't bubble\\n  $.fn.triggerHandler = function(event, args){\\n    var e, result\\n    this.each(function(i, element){\\n      e = createProxy(isString(event) ? $.Event(event) : event)\\n      e._args = args\\n      e.target = element\\n      $.each(findHandlers(element, event.type || event), function(i, handler){\\n        result = handler.proxy(e)\\n        if (e.isImmediatePropagationStopped()) return false\\n      })\\n    })\\n    return result\\n  }\\n\\n  // shortcut methods for `.bind(event, fn)` for each event type\\n  ;('focusin focusout focus blur load resize scroll unload click dblclick '+\\n  'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave '+\\n  'change select keydown keypress keyup error').split(' ').forEach(function(event) {\\n    $.fn[event] = function(callback) {\\n      return (0 in arguments) ?\\n        this.bind(event, callback) :\\n        this.trigger(event)\\n    }\\n  })\\n\\n  $.Event = function(type, props) {\\n    if (!isString(type)) props = type, type = props.type\\n    var event = document.createEvent(specialEvents[type] || 'Events'), bubbles = true\\n    if (props) for (var name in props) (name == 'bubbles') ? (bubbles = !!props[name]) : (event[name] = props[name])\\n    event.initEvent(type, bubbles, true)\\n    return compatible(event)\\n  }\\n\\n})(Zepto)\\n\\n;(function($){\\n  var jsonpID = +new Date(),\\n      document = window.document,\\n      key,\\n      name,\\n      rscript = /<script\\\\b[^<]*(?:(?!<\\\\/script>)<[^<]*)*<\\\\/script>/gi,\\n      scriptTypeRE = /^(?:text|application)\\\\/javascript/i,\\n      xmlTypeRE = /^(?:text|application)\\\\/xml/i,\\n      jsonType = 'application/json',\\n      htmlType = 'text/html',\\n      blankRE = /^\\\\s*$/,\\n      originAnchor = document.createElement('a')\\n\\n  originAnchor.href = window.location.href\\n\\n  // trigger a custom event and return false if it was cancelled\\n  function triggerAndReturn(context, eventName, data) {\\n    var event = $.Event(eventName)\\n    $(context).trigger(event, data)\\n    return !event.isDefaultPrevented()\\n  }\\n\\n  // trigger an Ajax \\\"global\\\" event\\n  function triggerGlobal(settings, context, eventName, data) {\\n    if (settings.global) return triggerAndReturn(context || document, eventName, data)\\n  }\\n\\n  // Number of active Ajax requests\\n  $.active = 0\\n\\n  function ajaxStart(settings) {\\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart')\\n  }\\n  function ajaxStop(settings) {\\n    if (settings.global && !(--$.active)) triggerGlobal(settings, null, 'ajaxStop')\\n  }\\n\\n  // triggers an extra global event \\\"ajaxBeforeSend\\\" that's like \\\"ajaxSend\\\" but cancelable\\n  function ajaxBeforeSend(xhr, settings) {\\n    var context = settings.context\\n    if (settings.beforeSend.call(context, xhr, settings) === false ||\\n        triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false)\\n      return false\\n\\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings])\\n  }\\n  function ajaxSuccess(data, xhr, settings, deferred) {\\n    var context = settings.context, status = 'success'\\n    settings.success.call(context, data, status, xhr)\\n    if (deferred) deferred.resolveWith(context, [data, status, xhr])\\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data])\\n    ajaxComplete(status, xhr, settings)\\n  }\\n  // type: \\\"timeout\\\", \\\"error\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxError(error, type, xhr, settings, deferred) {\\n    var context = settings.context\\n    settings.error.call(context, xhr, type, error)\\n    if (deferred) deferred.rejectWith(context, [xhr, type, error])\\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type])\\n    ajaxComplete(type, xhr, settings)\\n  }\\n  // status: \\\"success\\\", \\\"notmodified\\\", \\\"error\\\", \\\"timeout\\\", \\\"abort\\\", \\\"parsererror\\\"\\n  function ajaxComplete(status, xhr, settings) {\\n    var context = settings.context\\n    settings.complete.call(context, xhr, status)\\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings])\\n    ajaxStop(settings)\\n  }\\n\\n  function ajaxDataFilter(data, type, settings) {\\n    if (settings.dataFilter == empty) return data\\n    var context = settings.context\\n    return settings.dataFilter.call(context, data, type)\\n  }\\n\\n  // Empty function, used as default callback\\n  function empty() {}\\n\\n  $.ajaxJSONP = function(options, deferred){\\n    if (!('type' in options)) return $.ajax(options)\\n\\n    var _callbackName = options.jsonpCallback,\\n      callbackName = ($.isFunction(_callbackName) ?\\n        _callbackName() : _callbackName) || ('Zepto' + (jsonpID++)),\\n      script = document.createElement('script'),\\n      originalCallback = window[callbackName],\\n      responseData,\\n      abort = function(errorType) {\\n        $(script).triggerHandler('error', errorType || 'abort')\\n      },\\n      xhr = { abort: abort }, abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    $(script).on('load error', function(e, errorType){\\n      clearTimeout(abortTimeout)\\n      $(script).off().remove()\\n\\n      if (e.type == 'error' || !responseData) {\\n        ajaxError(null, errorType || 'error', xhr, options, deferred)\\n      } else {\\n        ajaxSuccess(responseData[0], xhr, options, deferred)\\n      }\\n\\n      window[callbackName] = originalCallback\\n      if (responseData && $.isFunction(originalCallback))\\n        originalCallback(responseData[0])\\n\\n      originalCallback = responseData = undefined\\n    })\\n\\n    if (ajaxBeforeSend(xhr, options) === false) {\\n      abort('abort')\\n      return xhr\\n    }\\n\\n    window[callbackName] = function(){\\n      responseData = arguments\\n    }\\n\\n    script.src = options.url.replace(/\\\\?(.+)=\\\\?/, '?$1=' + callbackName)\\n    document.head.appendChild(script)\\n\\n    if (options.timeout > 0) abortTimeout = setTimeout(function(){\\n      abort('timeout')\\n    }, options.timeout)\\n\\n    return xhr\\n  }\\n\\n  $.ajaxSettings = {\\n    // Default type of request\\n    type: 'GET',\\n    // Callback that is executed before request\\n    beforeSend: empty,\\n    // Callback that is executed if the request succeeds\\n    success: empty,\\n    // Callback that is executed the the server drops error\\n    error: empty,\\n    // Callback that is executed on request complete (both: error and success)\\n    complete: empty,\\n    // The context for the callbacks\\n    context: null,\\n    // Whether to trigger \\\"global\\\" Ajax events\\n    global: true,\\n    // Transport\\n    xhr: function () {\\n      return new window.XMLHttpRequest()\\n    },\\n    // MIME types mapping\\n    // IIS returns Javascript as \\\"application/x-javascript\\\"\\n    accepts: {\\n      script: 'text/javascript, application/javascript, application/x-javascript',\\n      json:   jsonType,\\n      xml:    'application/xml, text/xml',\\n      html:   htmlType,\\n      text:   'text/plain'\\n    },\\n    // Whether the request is to another domain\\n    crossDomain: false,\\n    // Default timeout\\n    timeout: 0,\\n    // Whether data should be serialized to string\\n    processData: true,\\n    // Whether the browser should be allowed to cache GET responses\\n    cache: true,\\n    //Used to handle the raw response data of XMLHttpRequest.\\n    //This is a pre-filtering function to sanitize the response.\\n    //The sanitized response should be returned\\n    dataFilter: empty\\n  }\\n\\n  function mimeToDataType(mime) {\\n    if (mime) mime = mime.split(';', 2)[0]\\n    return mime && ( mime == htmlType ? 'html' :\\n      mime == jsonType ? 'json' :\\n      scriptTypeRE.test(mime) ? 'script' :\\n      xmlTypeRE.test(mime) && 'xml' ) || 'text'\\n  }\\n\\n  function appendQuery(url, query) {\\n    if (query == '') return url\\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?')\\n  }\\n\\n  // serialize payload and append it to the URL for GET requests\\n  function serializeData(options) {\\n    if (options.processData && options.data && $.type(options.data) != \\\"string\\\")\\n      options.data = $.param(options.data, options.traditional)\\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType))\\n      options.url = appendQuery(options.url, options.data), options.data = undefined\\n  }\\n\\n  $.ajax = function(options){\\n    var settings = $.extend({}, options || {}),\\n        deferred = $.Deferred && $.Deferred(),\\n        urlAnchor, hashIndex\\n    for (key in $.ajaxSettings) if (settings[key] === undefined) settings[key] = $.ajaxSettings[key]\\n\\n    ajaxStart(settings)\\n\\n    if (!settings.crossDomain) {\\n      urlAnchor = document.createElement('a')\\n      urlAnchor.href = settings.url\\n      // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049\\n      urlAnchor.href = urlAnchor.href\\n      settings.crossDomain = (originAnchor.protocol + '//' + originAnchor.host) !== (urlAnchor.protocol + '//' + urlAnchor.host)\\n    }\\n\\n    if (!settings.url) settings.url = window.location.toString()\\n    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex)\\n    serializeData(settings)\\n\\n    var dataType = settings.dataType, hasPlaceholder = /\\\\?.+=\\\\?/.test(settings.url)\\n    if (hasPlaceholder) dataType = 'jsonp'\\n\\n    if (settings.cache === false || (\\n         (!options || options.cache !== true) &&\\n         ('script' == dataType || 'jsonp' == dataType)\\n        ))\\n      settings.url = appendQuery(settings.url, '_=' + Date.now())\\n\\n    if ('jsonp' == dataType) {\\n      if (!hasPlaceholder)\\n        settings.url = appendQuery(settings.url,\\n          settings.jsonp ? (settings.jsonp + '=?') : settings.jsonp === false ? '' : 'callback=?')\\n      return $.ajaxJSONP(settings, deferred)\\n    }\\n\\n    var mime = settings.accepts[dataType],\\n        headers = { },\\n        setHeader = function(name, value) { headers[name.toLowerCase()] = [name, value] },\\n        protocol = /^([\\\\w-]+:)\\\\/\\\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\\n        xhr = settings.xhr(),\\n        nativeSetHeader = xhr.setRequestHeader,\\n        abortTimeout\\n\\n    if (deferred) deferred.promise(xhr)\\n\\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest')\\n    setHeader('Accept', mime || '*/*')\\n    if (mime = settings.mimeType || mime) {\\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0]\\n      xhr.overrideMimeType && xhr.overrideMimeType(mime)\\n    }\\n    if (settings.contentType || (settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET'))\\n      setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded')\\n\\n    if (settings.headers) for (name in settings.headers) setHeader(name, settings.headers[name])\\n    xhr.setRequestHeader = setHeader\\n\\n    xhr.onreadystatechange = function(){\\n      if (xhr.readyState == 4) {\\n        xhr.onreadystatechange = empty\\n        clearTimeout(abortTimeout)\\n        var result, error = false\\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304 || (xhr.status == 0 && protocol == 'file:')) {\\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'))\\n\\n          if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob')\\n            result = xhr.response\\n          else {\\n            result = xhr.responseText\\n\\n            try {\\n              // http://perfectionkills.com/global-eval-what-are-the-options/\\n              // sanitize response accordingly if data filter callback provided\\n              result = ajaxDataFilter(result, dataType, settings)\\n              if (dataType == 'script')    (1,eval)(result)\\n              else if (dataType == 'xml')  result = xhr.responseXML\\n              else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result)\\n            } catch (e) { error = e }\\n\\n            if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred)\\n          }\\n\\n          ajaxSuccess(result, xhr, settings, deferred)\\n        } else {\\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred)\\n        }\\n      }\\n    }\\n\\n    if (ajaxBeforeSend(xhr, settings) === false) {\\n      xhr.abort()\\n      ajaxError(null, 'abort', xhr, settings, deferred)\\n      return xhr\\n    }\\n\\n    var async = 'async' in settings ? settings.async : true\\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password)\\n\\n    if (settings.xhrFields) for (name in settings.xhrFields) xhr[name] = settings.xhrFields[name]\\n\\n    for (name in headers) nativeSetHeader.apply(xhr, headers[name])\\n\\n    if (settings.timeout > 0) abortTimeout = setTimeout(function(){\\n        xhr.onreadystatechange = empty\\n        xhr.abort()\\n        ajaxError(null, 'timeout', xhr, settings, deferred)\\n      }, settings.timeout)\\n\\n    // avoid sending empty string (#319)\\n    xhr.send(settings.data ? settings.data : null)\\n    return xhr\\n  }\\n\\n  // handle optional data/success arguments\\n  function parseArguments(url, data, success, dataType) {\\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined\\n    if (!$.isFunction(success)) dataType = success, success = undefined\\n    return {\\n      url: url\\n    , data: data\\n    , success: success\\n    , dataType: dataType\\n    }\\n  }\\n\\n  $.get = function(/* url, data, success, dataType */){\\n    return $.ajax(parseArguments.apply(null, arguments))\\n  }\\n\\n  $.post = function(/* url, data, success, dataType */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.type = 'POST'\\n    return $.ajax(options)\\n  }\\n\\n  $.getJSON = function(/* url, data, success */){\\n    var options = parseArguments.apply(null, arguments)\\n    options.dataType = 'json'\\n    return $.ajax(options)\\n  }\\n\\n  $.fn.load = function(url, data, success){\\n    if (!this.length) return this\\n    var self = this, parts = url.split(/\\\\s/), selector,\\n        options = parseArguments(url, data, success),\\n        callback = options.success\\n    if (parts.length > 1) options.url = parts[0], selector = parts[1]\\n    options.success = function(response){\\n      self.html(selector ?\\n        $('<div>').html(response.replace(rscript, \\\"\\\")).find(selector)\\n        : response)\\n      callback && callback.apply(self, arguments)\\n    }\\n    $.ajax(options)\\n    return this\\n  }\\n\\n  var escape = encodeURIComponent\\n\\n  function serialize(params, obj, traditional, scope){\\n    var type, array = $.isArray(obj), hash = $.isPlainObject(obj)\\n    $.each(obj, function(key, value) {\\n      type = $.type(value)\\n      if (scope) key = traditional ? scope :\\n        scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']'\\n      // handle data in serializeArray() format\\n      if (!scope && array) params.add(value.name, value.value)\\n      // recurse into nested objects\\n      else if (type == \\\"array\\\" || (!traditional && type == \\\"object\\\"))\\n        serialize(params, value, traditional, key)\\n      else params.add(key, value)\\n    })\\n  }\\n\\n  $.param = function(obj, traditional){\\n    var params = []\\n    params.add = function(key, value) {\\n      if ($.isFunction(value)) value = value()\\n      if (value == null) value = \\\"\\\"\\n      this.push(escape(key) + '=' + escape(value))\\n    }\\n    serialize(params, obj, traditional)\\n    return params.join('&').replace(/%20/g, '+')\\n  }\\n})(Zepto)\\n\\n;(function($){\\n  $.fn.serializeArray = function() {\\n    var name, type, result = [],\\n      add = function(value) {\\n        if (value.forEach) return value.forEach(add)\\n        result.push({ name: name, value: value })\\n      }\\n    if (this[0]) $.each(this[0].elements, function(_, field){\\n      type = field.type, name = field.name\\n      if (name && field.nodeName.toLowerCase() != 'fieldset' &&\\n        !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' &&\\n        ((type != 'radio' && type != 'checkbox') || field.checked))\\n          add($(field).val())\\n    })\\n    return result\\n  }\\n\\n  $.fn.serialize = function(){\\n    var result = []\\n    this.serializeArray().forEach(function(elm){\\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value))\\n    })\\n    return result.join('&')\\n  }\\n\\n  $.fn.submit = function(callback) {\\n    if (0 in arguments) this.bind('submit', callback)\\n    else if (this.length) {\\n      var event = $.Event('submit')\\n      this.eq(0).trigger(event)\\n      if (!event.isDefaultPrevented()) this.get(0).submit()\\n    }\\n    return this\\n  }\\n\\n})(Zepto)\\n\\n;(function(){\\n  // getComputedStyle shouldn't freak out when called\\n  // without a valid element as argument\\n  try {\\n    getComputedStyle(undefined)\\n  } catch(e) {\\n    var nativeGetComputedStyle = getComputedStyle\\n    window.getComputedStyle = function(element, pseudoElement){\\n      try {\\n        return nativeGetComputedStyle(element, pseudoElement)\\n      } catch(e) {\\n        return null\\n      }\\n    }\\n  }\\n})()\\n  return Zepto\\n}))\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvemVwdG8vZGlzdC96ZXB0by5qcz9kN2E4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG1IQUFtSCw0RUFBNEUseUJBQXlCLGlDQUFpQyx5QkFBeUIsNkJBQTZCLGtNQUFrTSxpQkFBaUIsb0JBQW9CLDRHQUE0RyxnbUJBQWdtQiw2TEFBNkwseUdBQXlHLHNEQUFzRCx3RkFBd0YsNFlBQTRZLDBEQUEwRCxpQ0FBaUMsbURBQW1ELHdvQkFBd29CLDBCQUEwQixpR0FBaUcsa0NBQWtDLHFDQUFxQyxnQ0FBZ0MsMENBQTBDLGdDQUFnQywwREFBMEQsZ0NBQWdDLGlDQUFpQyxpQ0FBaUMsbUdBQW1HLCtCQUErQiw0UUFBNFEsK0JBQStCLDBDQUEwQyxzQkFBc0IsR0FBRyw2QkFBNkIsaUVBQWlFLDZCQUE2QixvREFBb0Qsc0NBQXNDLEdBQUcsNkJBQTZCLCtNQUErTSwyQkFBMkIsK0NBQStDLG9DQUFvQyxHQUFHLDhCQUE4QixrSUFBa0ksd0NBQXdDLHNHQUFzRyx5Q0FBeUMsZ0VBQWdFLDZUQUE2VCwwQ0FBMEMsa0NBQWtDLDJIQUEySCxzQ0FBc0MsTUFBTSxpQ0FBaUMsd0RBQXdELFNBQVMsc0ZBQXNGLHdYQUF3WCxxTEFBcUwsZ1ZBQWdWLDhDQUE4QyxRQUFRLHdDQUF3Qyx1RUFBdUUsaUhBQWlILFFBQVEsdUJBQXVCLGdQQUFnUCxzQ0FBc0Msd0tBQXdLLDJDQUEyQyxzUUFBc1EsZ01BQWdNLHFvQkFBcW9CLDJQQUEyUCwrc0JBQStzQixtR0FBbUcsc1FBQXNRLCtDQUErQyw2Q0FBNkMsb0dBQW9HLG9HQUFvRyxpSkFBaUosMEVBQTBFLGlJQUFpSSxzRkFBc0YseURBQXlELGlDQUFpQyw0QkFBNEIseUJBQXlCLHdQQUF3UCxrK0JBQWsrQiwwQ0FBMEMseUVBQXlFLG9GQUFvRiw4REFBOEQsZ0NBQWdDLHFIQUFxSCxvREFBb0QseUVBQXlFLGdEQUFnRCxzRkFBc0YseUdBQXlHLG1PQUFtTywrT0FBK08sV0FBVyxvTUFBb00sZ0ZBQWdGLFdBQVcsMkJBQTJCLEtBQUssMEtBQTBLLHdFQUF3RSxtQ0FBbUMsMkxBQTJMLDJDQUEyQyx5REFBeUQsd0RBQXdELHNFQUFzRSw0REFBNEQsRUFBRSxjQUFjLEVBQUUsMEJBQTBCLDJDQUEyQyxxRkFBcUYscUJBQXFCLE9BQU8sa0dBQWtHLHlDQUF5QyxzR0FBc0csaUNBQWlDLDRDQUE0QyxnREFBZ0QsbUJBQW1CLHFCQUFxQiwrRkFBK0YsT0FBTyw2SEFBNkgsNEJBQTRCLDRDQUE0QyxpREFBaUQsaU1BQWlNLHlFQUF5RSwwRkFBMEYsa1dBQWtXLGtEQUFrRCxzQkFBc0IsT0FBTyxxR0FBcUcsaUZBQWlGLDhIQUE4SCw2Q0FBNkMsNEJBQTRCLFNBQVMseUJBQXlCLHFEQUFxRCxtQ0FBbUMscVNBQXFTLGNBQWMsa0NBQWtDLDBCQUEwQixxR0FBcUcsMkJBQTJCLG9CQUFvQix3QkFBd0IsaUNBQWlDLDBCQUEwQixvQ0FBb0MsNEZBQTRGLFFBQVEsZ0NBQWdDLHNEQUFzRCw4REFBOEQsMkJBQTJCLGtDQUFrQywwSEFBMEgsMERBQTBELFNBQVMsdUNBQXVDLCtEQUErRCw4QkFBOEIseUVBQXlFLCtCQUErQixzSEFBc0gscUVBQXFFLGVBQWUscU5BQXFOLG1FQUFtRSxVQUFVLDhCQUE4QiwrQkFBK0Isc0NBQXNDLCtIQUErSCxRQUFRLHlCQUF5QiwrRUFBK0UseUJBQXlCLDhFQUE4RSx3QkFBd0IsNEZBQTRGLGdDQUFnQyxpS0FBaUssMkZBQTJGLDBEQUEwRCxZQUFZLHNIQUFzSCxtQ0FBbUMsNkJBQTZCLDRDQUE0QyxtSEFBbUgsMFBBQTBQLCtCQUErQixtQ0FBbUMsc0hBQXNILCtGQUErRix3RUFBd0UsV0FBVyxvREFBb0Qsa0NBQWtDLHdFQUF3RSxvQ0FBb0MsNENBQTRDLHdCQUF3QixtQkFBbUIsNkJBQTZCLG9DQUFvQyw2REFBNkQsUUFBUSxvQ0FBb0MsaURBQWlELHNFQUFzRSxvQkFBb0IsVUFBVSxtQkFBbUIseUJBQXlCLG9DQUFvQyxzQkFBc0IsUUFBUSwrRUFBK0Usd0NBQXdDLHNCQUFzQixRQUFRLHdCQUF3QixvQ0FBb0MsK05BQStOLFFBQVEseUNBQXlDLHNEQUFzRCxpQ0FBaUMsaU5BQWlOLDZJQUE2SSxRQUFRLG9DQUFvQyxzQkFBc0IsMlBBQTJQLDBCQUEwQixzQ0FBc0MsaUZBQWlGLHlNQUF5TSxRQUFRLDBCQUEwQixzQ0FBc0MsMERBQTBELDJCQUEyQix5QkFBeUIsbUNBQW1DLDhCQUE4QixRQUFRLHdCQUF3QixxREFBcUQsaUNBQWlDLG9DQUFvQyxxQ0FBcUMsb0dBQW9HLFFBQVEsZ0NBQWdDLHlFQUF5RSxnQ0FBZ0MscUVBQXFFLDRCQUE0QixpRUFBaUUsZ0lBQWdJLDBEQUEwRCw0QkFBNEIsaUVBQWlFLCtJQUErSSw2RUFBNkUsbUNBQW1DLHlPQUF5Tyx1T0FBdU8sUUFBUSxrQ0FBa0Msb0NBQW9DLG9FQUFvRSxnREFBZ0QsUUFBUSxRQUFRLG1DQUFtQyx1R0FBdUcseUVBQXlFLDhDQUE4QyxrQ0FBa0Msd0VBQXdFLG9CQUFvQixRQUFRLG1DQUFtQyxpUUFBaVEsNEJBQTRCLDZCQUE2QixrRkFBa0YseUVBQXlFLFVBQVUsT0FBTyx3R0FBd0csdUJBQXVCLHNEQUFzRCxPQUFPLHFDQUFxQywwREFBMEQseUxBQXlMLHlIQUF5SCxvSEFBb0gsMkpBQTJKLGdCQUFnQixpRUFBaUUsa0xBQWtMLE9BQU8sc0NBQXNDLG1DQUFtQywyRUFBMkUsMkpBQTJKLDhCQUE4QiwwREFBMEQsNEdBQTRHLGdIQUFnSCxvQ0FBb0MsU0FBUywrREFBK0QscUVBQXFFLGlEQUFpRCxtR0FBbUcsT0FBTyx3SEFBd0gsNENBQTRDLGdHQUFnRyxVQUFVLHNDQUFzQyx5QkFBeUIsU0FBUyxRQUFRLGdDQUFnQyx1R0FBdUcsZ0NBQWdDLHNGQUFzRixrREFBa0QsdUJBQXVCLGdDQUFnQyxxRUFBcUUseU1BQXlNLDBFQUEwRSxpSEFBaUgsUUFBUSxtQ0FBbUMsdUNBQXVDLGtPQUFrTywyRUFBMkUscURBQXFELFFBQVEseUNBQXlDLHFFQUFxRSx1SUFBdUksMklBQTJJLFVBQVUsUUFBUSxrQ0FBa0MsMk9BQTJPLHlCQUF5Qix1QkFBdUIscUNBQXFDLFFBQVEsbUNBQW1DLGdQQUFnUCwwQkFBMEIsdUJBQXVCLHFDQUFxQyxRQUFRLDZCQUE2QiwyUkFBMlIsa0JBQWtCLDJtQkFBMm1CLHVHQUF1RyxPQUFPLGlDQUFpQyxtQ0FBbUMsMk9BQTJPLFFBQVEsS0FBSyxzR0FBc0csZ0RBQWdELHdFQUF3RSw0QkFBNEIsMkNBQTJDLHdTQUF3UyxzR0FBc0csUUFBUSxLQUFLLHlDQUF5QyxrRUFBa0UsU0FBUyx1REFBdUQseU1BQXlNLDZGQUE2RiwrSUFBK0ksb0dBQW9HLDBDQUEwQyx3TkFBd04sMENBQTBDLGlIQUFpSCwySUFBMkksd2FBQXdhLDhOQUE4TiwySkFBMkosNkpBQTZKLGFBQWEsWUFBWSxVQUFVLFFBQVEsa09BQWtPLHlEQUF5RCxLQUFLLG9OQUFvTiw4RUFBOEUsYUFBYSxxSUFBcUksZ0NBQWdDLHNCQUFzQix5QkFBeUIsbUVBQW1FLHFDQUFxQyxrQkFBa0Isa0RBQWtELGtKQUFrSix5REFBeUQseURBQXlELHNKQUFzSiwyT0FBMk8sTUFBTSwyQkFBMkIsdURBQXVELGlEQUFpRCxLQUFLLDZCQUE2Qiw4RUFBOEUsc0RBQXNELDhHQUE4RyxnQ0FBZ0MsMEVBQTBFLDRFQUE0RSwwSEFBMEgsa1BBQWtQLCtLQUErSyw0R0FBNEcsZ1RBQWdULCtNQUErTSxNQUFNLDREQUE0RCxrQ0FBa0Msb0RBQW9ELDZFQUE2RSx3TUFBd00sUUFBUSxNQUFNLGlCQUFpQiwyQkFBMkIsdUNBQXVDLHdGQUF3RixpQ0FBaUMsa0ZBQWtGLDJEQUEyRCw4QkFBOEIsbUJBQW1CLDBGQUEwRixPQUFPLGtEQUFrRCxPQUFPLE9BQU8seURBQXlELEtBQUssa0RBQWtELGdEQUFnRCw0Q0FBNEMsMkNBQTJDLHlEQUF5RCw2REFBNkQsa0NBQWtDLFlBQVksa0NBQWtDLGFBQWEsMkdBQTJHLDZLQUE2SywwQ0FBMEMsZ0RBQWdELDRGQUE0Riw0RUFBNEUsMkhBQTJILGlEQUFpRCx3VUFBd1UsdUJBQXVCLG1DQUFtQyx3QkFBd0IsdUJBQXVCLGdLQUFnSywwREFBMEQsb0RBQW9ELDBEQUEwRCxxREFBcUQsNENBQTRDLHFGQUFxRix5Q0FBeUMsdUZBQXVGLCtEQUErRCxtRkFBbUYseUNBQXlDLDBEQUEwRCw0QkFBNEIsOFVBQThVLDBDQUEwQyxvR0FBb0csZ0RBQWdELG1IQUFtSCw0Q0FBNEMseUNBQXlDLDRHQUE0RyxTQUFTLHVGQUF1RixNQUFNLG1EQUFtRCw0REFBNEQseUNBQXlDLGdEQUFnRCw0QkFBNEIsMk5BQTJOLHNEQUFzRCxNQUFNLDJDQUEyQyx3SkFBd0osOFVBQThVLE1BQU0sdUxBQXVMLHdEQUF3RCxpTUFBaU0seUdBQXlHLFFBQVEseUJBQXlCLHlFQUF5RSwyT0FBMk8sd0NBQXdDLDJHQUEyRyxLQUFLLHdDQUF3QyxvVkFBb1YsS0FBSyxhQUFhLGFBQWEsa2xCQUFrbEIsc0hBQXNILHlHQUF5Ryw2RkFBNkYsMkZBQTJGLDhGQUE4RixpQ0FBaUMsMEZBQTBGLDhJQUE4SSxpU0FBaVMseURBQXlELCtTQUErUyw2SEFBNkgsMlJBQTJSLGlKQUFpSiwwTEFBMEwscURBQXFELHNKQUFzSix3RUFBd0UsZ0RBQWdELCtYQUErWCwwRUFBMEUsZ0JBQWdCLGVBQWUsbUhBQW1ILHFIQUFxSCxnRkFBZ0YsT0FBTyx1RUFBdUUsbU5BQW1OLHNEQUFzRCwrQ0FBK0MsMENBQTBDLHVDQUF1QywyTEFBMkwsK0JBQStCLHlDQUF5Qyx3QkFBd0IseWlCQUF5aUIsaURBQWlELDJHQUEyRyxxTkFBcU4scWVBQXFlLHFDQUFxQyxvQ0FBb0MsK0xBQStMLHdDQUF3QyxnRkFBZ0YsSUFBSSxZQUFZLHlHQUF5RyxnV0FBZ1csaUNBQWlDLGdDQUFnQyxlQUFlLHFQQUFxUCxpV0FBaVcsaWxCQUFpbEIsdU9BQXVPLG1FQUFtRSxFQUFFLDhDQUE4Qyw4Q0FBOEMsNFpBQTRaLGlJQUFpSSxnWkFBZ1osa0NBQWtDLHdPQUF3TyxvUEFBb1AsNERBQTRELDJkQUEyZCxZQUFZLFlBQVksdUdBQXVHLHFFQUFxRSxPQUFPLGlIQUFpSCxTQUFTLE9BQU8sc0RBQXNELHFHQUFxRywwWUFBMFksbUlBQW1JLHdJQUF3SSwwR0FBMEcseUtBQXlLLDJGQUEyRixLQUFLLDJEQUEyRCwrREFBK0QsNERBQTRELHFIQUFxSCxxREFBcUQseUhBQXlILCtDQUErQywwU0FBMFMsb0xBQW9MLDJDQUEyQywrRkFBK0YsMkdBQTJHLGdlQUFnZSxNQUFNLDJDQUEyQyw4REFBOEQsa0pBQWtKLGdHQUFnRyxHQUFHLGFBQWEsYUFBYSxzQ0FBc0MsaUVBQWlFLDZFQUE2RSwyQkFBMkIsVUFBVSwrREFBK0QsaVVBQWlVLHlCQUF5QixrQ0FBa0MsdUVBQXVFLDhGQUE4RixtQ0FBbUMsd0NBQXdDLG9GQUFvRiwwSUFBMEksc0JBQXNCLEtBQUssYUFBYSxZQUFZLDBHQUEwRyxzQ0FBc0MsV0FBVyxvSEFBb0gsYUFBYSx3RUFBd0UsV0FBVyw4QkFBOEIsT0FBTyxLQUFLLEdBQUcsc0JBQXNCIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyogWmVwdG8gdjEuMi4wIC0gemVwdG8gZXZlbnQgYWpheCBmb3JtIGllIC0gemVwdG9qcy5jb20vbGljZW5zZSAqL1xcbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXFxuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGZhY3RvcnkoZ2xvYmFsKSB9KVxcbiAgZWxzZVxcbiAgICBmYWN0b3J5KGdsb2JhbClcXG59KHRoaXMsIGZ1bmN0aW9uKHdpbmRvdykge1xcbiAgdmFyIFplcHRvID0gKGZ1bmN0aW9uKCkge1xcbiAgdmFyIHVuZGVmaW5lZCwga2V5LCAkLCBjbGFzc0xpc3QsIGVtcHR5QXJyYXkgPSBbXSwgY29uY2F0ID0gZW1wdHlBcnJheS5jb25jYXQsIGZpbHRlciA9IGVtcHR5QXJyYXkuZmlsdGVyLCBzbGljZSA9IGVtcHR5QXJyYXkuc2xpY2UsXFxuICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxcbiAgICBlbGVtZW50RGlzcGxheSA9IHt9LCBjbGFzc0NhY2hlID0ge30sXFxuICAgIGNzc051bWJlciA9IHsgJ2NvbHVtbi1jb3VudCc6IDEsICdjb2x1bW5zJzogMSwgJ2ZvbnQtd2VpZ2h0JzogMSwgJ2xpbmUtaGVpZ2h0JzogMSwnb3BhY2l0eSc6IDEsICd6LWluZGV4JzogMSwgJ3pvb20nOiAxIH0sXFxuICAgIGZyYWdtZW50UkUgPSAvXlxcXFxzKjwoXFxcXHcrfCEpW14+XSo+LyxcXG4gICAgc2luZ2xlVGFnUkUgPSAvXjwoXFxcXHcrKVxcXFxzKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvLFxcbiAgICB0YWdFeHBhbmRlclJFID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Ol0rKVtePl0qKVxcXFwvPi9pZyxcXG4gICAgcm9vdE5vZGVSRSA9IC9eKD86Ym9keXxodG1sKSQvaSxcXG4gICAgY2FwaXRhbFJFID0gLyhbQS1aXSkvZyxcXG5cXG4gICAgLy8gc3BlY2lhbCBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIGdldC9zZXQgdmlhIG1ldGhvZCBjYWxsc1xcbiAgICBtZXRob2RBdHRyaWJ1dGVzID0gWyd2YWwnLCAnY3NzJywgJ2h0bWwnLCAndGV4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdvZmZzZXQnXSxcXG5cXG4gICAgYWRqYWNlbmN5T3BlcmF0b3JzID0gWyAnYWZ0ZXInLCAncHJlcGVuZCcsICdiZWZvcmUnLCAnYXBwZW5kJyBdLFxcbiAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyksXFxuICAgIHRhYmxlUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKSxcXG4gICAgY29udGFpbmVycyA9IHtcXG4gICAgICAndHInOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxcbiAgICAgICd0Ym9keSc6IHRhYmxlLCAndGhlYWQnOiB0YWJsZSwgJ3Rmb290JzogdGFibGUsXFxuICAgICAgJ3RkJzogdGFibGVSb3csICd0aCc6IHRhYmxlUm93LFxcbiAgICAgICcqJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcXG4gICAgfSxcXG4gICAgcmVhZHlSRSA9IC9jb21wbGV0ZXxsb2FkZWR8aW50ZXJhY3RpdmUvLFxcbiAgICBzaW1wbGVTZWxlY3RvclJFID0gL15bXFxcXHctXSokLyxcXG4gICAgY2xhc3MydHlwZSA9IHt9LFxcbiAgICB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmcsXFxuICAgIHplcHRvID0ge30sXFxuICAgIGNhbWVsaXplLCB1bmlxLFxcbiAgICB0ZW1wUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxuICAgIHByb3BNYXAgPSB7XFxuICAgICAgJ3RhYmluZGV4JzogJ3RhYkluZGV4JyxcXG4gICAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxcbiAgICAgICdmb3InOiAnaHRtbEZvcicsXFxuICAgICAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXFxuICAgICAgJ21heGxlbmd0aCc6ICdtYXhMZW5ndGgnLFxcbiAgICAgICdjZWxsc3BhY2luZyc6ICdjZWxsU3BhY2luZycsXFxuICAgICAgJ2NlbGxwYWRkaW5nJzogJ2NlbGxQYWRkaW5nJyxcXG4gICAgICAncm93c3Bhbic6ICdyb3dTcGFuJyxcXG4gICAgICAnY29sc3Bhbic6ICdjb2xTcGFuJyxcXG4gICAgICAndXNlbWFwJzogJ3VzZU1hcCcsXFxuICAgICAgJ2ZyYW1lYm9yZGVyJzogJ2ZyYW1lQm9yZGVyJyxcXG4gICAgICAnY29udGVudGVkaXRhYmxlJzogJ2NvbnRlbnRFZGl0YWJsZSdcXG4gICAgfSxcXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHxcXG4gICAgICBmdW5jdGlvbihvYmplY3QpeyByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgQXJyYXkgfVxcblxcbiAgemVwdG8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKSB7XFxuICAgIGlmICghc2VsZWN0b3IgfHwgIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuIGZhbHNlXFxuICAgIHZhciBtYXRjaGVzU2VsZWN0b3IgPSBlbGVtZW50Lm1hdGNoZXMgfHwgZWxlbWVudC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvciB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5tYXRjaGVzU2VsZWN0b3JcXG4gICAgaWYgKG1hdGNoZXNTZWxlY3RvcikgcmV0dXJuIG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKVxcbiAgICAvLyBmYWxsIGJhY2sgdG8gcGVyZm9ybWluZyBhIHNlbGVjdG9yOlxcbiAgICB2YXIgbWF0Y2gsIHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSwgdGVtcCA9ICFwYXJlbnRcXG4gICAgaWYgKHRlbXApIChwYXJlbnQgPSB0ZW1wUGFyZW50KS5hcHBlbmRDaGlsZChlbGVtZW50KVxcbiAgICBtYXRjaCA9IH56ZXB0by5xc2EocGFyZW50LCBzZWxlY3RvcikuaW5kZXhPZihlbGVtZW50KVxcbiAgICB0ZW1wICYmIHRlbXBQYXJlbnQucmVtb3ZlQ2hpbGQoZWxlbWVudClcXG4gICAgcmV0dXJuIG1hdGNoXFxuICB9XFxuXFxuICBmdW5jdGlvbiB0eXBlKG9iaikge1xcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBTdHJpbmcob2JqKSA6XFxuICAgICAgY2xhc3MydHlwZVt0b1N0cmluZy5jYWxsKG9iaildIHx8IFxcXCJvYmplY3RcXFwiXFxuICB9XFxuXFxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlKHZhbHVlKSA9PSBcXFwiZnVuY3Rpb25cXFwiIH1cXG4gIGZ1bmN0aW9uIGlzV2luZG93KG9iaikgICAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93IH1cXG4gIGZ1bmN0aW9uIGlzRG9jdW1lbnQob2JqKSAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iai5ub2RlVHlwZSA9PSBvYmouRE9DVU1FTlRfTk9ERSB9XFxuICBmdW5jdGlvbiBpc09iamVjdChvYmopICAgICB7IHJldHVybiB0eXBlKG9iaikgPT0gXFxcIm9iamVjdFxcXCIgfVxcbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcXG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgIWlzV2luZG93KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbGlrZUFycmF5KG9iaikge1xcbiAgICB2YXIgbGVuZ3RoID0gISFvYmogJiYgJ2xlbmd0aCcgaW4gb2JqICYmIG9iai5sZW5ndGgsXFxuICAgICAgdHlwZSA9ICQudHlwZShvYmopXFxuXFxuICAgIHJldHVybiAnZnVuY3Rpb24nICE9IHR5cGUgJiYgIWlzV2luZG93KG9iaikgJiYgKFxcbiAgICAgICdhcnJheScgPT0gdHlwZSB8fCBsZW5ndGggPT09IDAgfHxcXG4gICAgICAgICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iailcXG4gICAgKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkgeyByZXR1cm4gZmlsdGVyLmNhbGwoYXJyYXksIGZ1bmN0aW9uKGl0ZW0peyByZXR1cm4gaXRlbSAhPSBudWxsIH0pIH1cXG4gIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHsgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDAgPyAkLmZuLmNvbmNhdC5hcHBseShbXSwgYXJyYXkpIDogYXJyYXkgfVxcbiAgY2FtZWxpemUgPSBmdW5jdGlvbihzdHIpeyByZXR1cm4gc3RyLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hyKXsgcmV0dXJuIGNociA/IGNoci50b1VwcGVyQ2FzZSgpIDogJycgfSkgfVxcbiAgZnVuY3Rpb24gZGFzaGVyaXplKHN0cikge1xcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzo6L2csICcvJylcXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpdKS9nLCAnJDFfJDInKVxcbiAgICAgICAgICAgLnJlcGxhY2UoLyhbYS16XFxcXGRdKShbQS1aXSkvZywgJyQxXyQyJylcXG4gICAgICAgICAgIC5yZXBsYWNlKC9fL2csICctJylcXG4gICAgICAgICAgIC50b0xvd2VyQ2FzZSgpXFxuICB9XFxuICB1bmlxID0gZnVuY3Rpb24oYXJyYXkpeyByZXR1cm4gZmlsdGVyLmNhbGwoYXJyYXksIGZ1bmN0aW9uKGl0ZW0sIGlkeCl7IHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pID09IGlkeCB9KSB9XFxuXFxuICBmdW5jdGlvbiBjbGFzc1JFKG5hbWUpIHtcXG4gICAgcmV0dXJuIG5hbWUgaW4gY2xhc3NDYWNoZSA/XFxuICAgICAgY2xhc3NDYWNoZVtuYW1lXSA6IChjbGFzc0NhY2hlW25hbWVdID0gbmV3IFJlZ0V4cCgnKF58XFxcXFxcXFxzKScgKyBuYW1lICsgJyhcXFxcXFxcXHN8JCknKSlcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1heWJlQWRkUHgobmFtZSwgdmFsdWUpIHtcXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT0gXFxcIm51bWJlclxcXCIgJiYgIWNzc051bWJlcltkYXNoZXJpemUobmFtZSldKSA/IHZhbHVlICsgXFxcInB4XFxcIiA6IHZhbHVlXFxuICB9XFxuXFxuICBmdW5jdGlvbiBkZWZhdWx0RGlzcGxheShub2RlTmFtZSkge1xcbiAgICB2YXIgZWxlbWVudCwgZGlzcGxheVxcbiAgICBpZiAoIWVsZW1lbnREaXNwbGF5W25vZGVOYW1lXSkge1xcbiAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKVxcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbWVudClcXG4gICAgICBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJykuZ2V0UHJvcGVydHlWYWx1ZShcXFwiZGlzcGxheVxcXCIpXFxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpXFxuICAgICAgZGlzcGxheSA9PSBcXFwibm9uZVxcXCIgJiYgKGRpc3BsYXkgPSBcXFwiYmxvY2tcXFwiKVxcbiAgICAgIGVsZW1lbnREaXNwbGF5W25vZGVOYW1lXSA9IGRpc3BsYXlcXG4gICAgfVxcbiAgICByZXR1cm4gZWxlbWVudERpc3BsYXlbbm9kZU5hbWVdXFxuICB9XFxuXFxuICBmdW5jdGlvbiBjaGlsZHJlbihlbGVtZW50KSB7XFxuICAgIHJldHVybiAnY2hpbGRyZW4nIGluIGVsZW1lbnQgP1xcbiAgICAgIHNsaWNlLmNhbGwoZWxlbWVudC5jaGlsZHJlbikgOlxcbiAgICAgICQubWFwKGVsZW1lbnQuY2hpbGROb2RlcywgZnVuY3Rpb24obm9kZSl7IGlmIChub2RlLm5vZGVUeXBlID09IDEpIHJldHVybiBub2RlIH0pXFxuICB9XFxuXFxuICBmdW5jdGlvbiBaKGRvbSwgc2VsZWN0b3IpIHtcXG4gICAgdmFyIGksIGxlbiA9IGRvbSA/IGRvbS5sZW5ndGggOiAwXFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykgdGhpc1tpXSA9IGRvbVtpXVxcbiAgICB0aGlzLmxlbmd0aCA9IGxlblxcbiAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3IgfHwgJydcXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLmZyYWdtZW50YCB0YWtlcyBhIGh0bWwgc3RyaW5nIGFuZCBhbiBvcHRpb25hbCB0YWcgbmFtZVxcbiAgLy8gdG8gZ2VuZXJhdGUgRE9NIG5vZGVzIGZyb20gdGhlIGdpdmVuIGh0bWwgc3RyaW5nLlxcbiAgLy8gVGhlIGdlbmVyYXRlZCBET00gbm9kZXMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5LlxcbiAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zIGZvciBleGFtcGxlIHRvIG1ha2VcXG4gIC8vIGl0IGNvbXBhdGlibGUgd2l0aCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIERPTSBmdWxseS5cXG4gIHplcHRvLmZyYWdtZW50ID0gZnVuY3Rpb24oaHRtbCwgbmFtZSwgcHJvcGVydGllcykge1xcbiAgICB2YXIgZG9tLCBub2RlcywgY29udGFpbmVyXFxuXFxuICAgIC8vIEEgc3BlY2lhbCBjYXNlIG9wdGltaXphdGlvbiBmb3IgYSBzaW5nbGUgdGFnXFxuICAgIGlmIChzaW5nbGVUYWdSRS50ZXN0KGh0bWwpKSBkb20gPSAkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoUmVnRXhwLiQxKSlcXG5cXG4gICAgaWYgKCFkb20pIHtcXG4gICAgICBpZiAoaHRtbC5yZXBsYWNlKSBodG1sID0gaHRtbC5yZXBsYWNlKHRhZ0V4cGFuZGVyUkUsIFxcXCI8JDE+PC8kMj5cXFwiKVxcbiAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIG5hbWUgPSBmcmFnbWVudFJFLnRlc3QoaHRtbCkgJiYgUmVnRXhwLiQxXFxuICAgICAgaWYgKCEobmFtZSBpbiBjb250YWluZXJzKSkgbmFtZSA9ICcqJ1xcblxcbiAgICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lcnNbbmFtZV1cXG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJycgKyBodG1sXFxuICAgICAgZG9tID0gJC5lYWNoKHNsaWNlLmNhbGwoY29udGFpbmVyLmNoaWxkTm9kZXMpLCBmdW5jdGlvbigpe1xcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMpXFxuICAgICAgfSlcXG4gICAgfVxcblxcbiAgICBpZiAoaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkge1xcbiAgICAgIG5vZGVzID0gJChkb20pXFxuICAgICAgJC5lYWNoKHByb3BlcnRpZXMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICAgIGlmIChtZXRob2RBdHRyaWJ1dGVzLmluZGV4T2Yoa2V5KSA+IC0xKSBub2Rlc1trZXldKHZhbHVlKVxcbiAgICAgICAgZWxzZSBub2Rlcy5hdHRyKGtleSwgdmFsdWUpXFxuICAgICAgfSlcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZG9tXFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5aYCBzd2FwcyBvdXQgdGhlIHByb3RvdHlwZSBvZiB0aGUgZ2l2ZW4gYGRvbWAgYXJyYXlcXG4gIC8vIG9mIG5vZGVzIHdpdGggYCQuZm5gIGFuZCB0aHVzIHN1cHBseWluZyBhbGwgdGhlIFplcHRvIGZ1bmN0aW9uc1xcbiAgLy8gdG8gdGhlIGFycmF5LiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiBpbiBwbHVnaW5zLlxcbiAgemVwdG8uWiA9IGZ1bmN0aW9uKGRvbSwgc2VsZWN0b3IpIHtcXG4gICAgcmV0dXJuIG5ldyBaKGRvbSwgc2VsZWN0b3IpXFxuICB9XFxuXFxuICAvLyBgJC56ZXB0by5pc1pgIHNob3VsZCByZXR1cm4gYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBaZXB0b1xcbiAgLy8gY29sbGVjdGlvbi4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gcGx1Z2lucy5cXG4gIHplcHRvLmlzWiA9IGZ1bmN0aW9uKG9iamVjdCkge1xcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgemVwdG8uWlxcbiAgfVxcblxcbiAgLy8gYCQuemVwdG8uaW5pdGAgaXMgWmVwdG8ncyBjb3VudGVycGFydCB0byBqUXVlcnkncyBgJC5mbi5pbml0YCBhbmRcXG4gIC8vIHRha2VzIGEgQ1NTIHNlbGVjdG9yIGFuZCBhbiBvcHRpb25hbCBjb250ZXh0IChhbmQgaGFuZGxlcyB2YXJpb3VzXFxuICAvLyBzcGVjaWFsIGNhc2VzKS5cXG4gIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXFxuICB6ZXB0by5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcXG4gICAgdmFyIGRvbVxcbiAgICAvLyBJZiBub3RoaW5nIGdpdmVuLCByZXR1cm4gYW4gZW1wdHkgWmVwdG8gY29sbGVjdGlvblxcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gemVwdG8uWigpXFxuICAgIC8vIE9wdGltaXplIGZvciBzdHJpbmcgc2VsZWN0b3JzXFxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PSAnc3RyaW5nJykge1xcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudHJpbSgpXFxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XFxuICAgICAgLy8gTm90ZTogSW4gYm90aCBDaHJvbWUgMjEgYW5kIEZpcmVmb3ggMTUsIERPTSBlcnJvciAxMlxcbiAgICAgIC8vIGlzIHRocm93biBpZiB0aGUgZnJhZ21lbnQgZG9lc24ndCBiZWdpbiB3aXRoIDxcXG4gICAgICBpZiAoc2VsZWN0b3JbMF0gPT0gJzwnICYmIGZyYWdtZW50UkUudGVzdChzZWxlY3RvcikpXFxuICAgICAgICBkb20gPSB6ZXB0by5mcmFnbWVudChzZWxlY3RvciwgUmVnRXhwLiQxLCBjb250ZXh0KSwgc2VsZWN0b3IgPSBudWxsXFxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XFxuICAgICAgLy8gbm9kZXMgZnJvbSB0aGVyZVxcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuICQoY29udGV4dCkuZmluZChzZWxlY3RvcilcXG4gICAgICAvLyBJZiBpdCdzIGEgQ1NTIHNlbGVjdG9yLCB1c2UgaXQgdG8gc2VsZWN0IG5vZGVzLlxcbiAgICAgIGVsc2UgZG9tID0gemVwdG8ucXNhKGRvY3VtZW50LCBzZWxlY3RvcilcXG4gICAgfVxcbiAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIGdpdmVuLCBjYWxsIGl0IHdoZW4gdGhlIERPTSBpcyByZWFkeVxcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSkgcmV0dXJuICQoZG9jdW1lbnQpLnJlYWR5KHNlbGVjdG9yKVxcbiAgICAvLyBJZiBhIFplcHRvIGNvbGxlY3Rpb24gaXMgZ2l2ZW4sIGp1c3QgcmV0dXJuIGl0XFxuICAgIGVsc2UgaWYgKHplcHRvLmlzWihzZWxlY3RvcikpIHJldHVybiBzZWxlY3RvclxcbiAgICBlbHNlIHtcXG4gICAgICAvLyBub3JtYWxpemUgYXJyYXkgaWYgYW4gYXJyYXkgb2Ygbm9kZXMgaXMgZ2l2ZW5cXG4gICAgICBpZiAoaXNBcnJheShzZWxlY3RvcikpIGRvbSA9IGNvbXBhY3Qoc2VsZWN0b3IpXFxuICAgICAgLy8gV3JhcCBET00gbm9kZXMuXFxuICAgICAgZWxzZSBpZiAoaXNPYmplY3Qoc2VsZWN0b3IpKVxcbiAgICAgICAgZG9tID0gW3NlbGVjdG9yXSwgc2VsZWN0b3IgPSBudWxsXFxuICAgICAgLy8gSWYgaXQncyBhIGh0bWwgZnJhZ21lbnQsIGNyZWF0ZSBub2RlcyBmcm9tIGl0XFxuICAgICAgZWxzZSBpZiAoZnJhZ21lbnRSRS50ZXN0KHNlbGVjdG9yKSlcXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLnRyaW0oKSwgUmVnRXhwLiQxLCBjb250ZXh0KSwgc2VsZWN0b3IgPSBudWxsXFxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XFxuICAgICAgLy8gbm9kZXMgZnJvbSB0aGVyZVxcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuICQoY29udGV4dCkuZmluZChzZWxlY3RvcilcXG4gICAgICAvLyBBbmQgbGFzdCBidXQgbm8gbGVhc3QsIGlmIGl0J3MgYSBDU1Mgc2VsZWN0b3IsIHVzZSBpdCB0byBzZWxlY3Qgbm9kZXMuXFxuICAgICAgZWxzZSBkb20gPSB6ZXB0by5xc2EoZG9jdW1lbnQsIHNlbGVjdG9yKVxcbiAgICB9XFxuICAgIC8vIGNyZWF0ZSBhIG5ldyBaZXB0byBjb2xsZWN0aW9uIGZyb20gdGhlIG5vZGVzIGZvdW5kXFxuICAgIHJldHVybiB6ZXB0by5aKGRvbSwgc2VsZWN0b3IpXFxuICB9XFxuXFxuICAvLyBgJGAgd2lsbCBiZSB0aGUgYmFzZSBgWmVwdG9gIG9iamVjdC4gV2hlbiBjYWxsaW5nIHRoaXNcXG4gIC8vIGZ1bmN0aW9uIGp1c3QgY2FsbCBgJC56ZXB0by5pbml0LCB3aGljaCBtYWtlcyB0aGUgaW1wbGVtZW50YXRpb25cXG4gIC8vIGRldGFpbHMgb2Ygc2VsZWN0aW5nIG5vZGVzIGFuZCBjcmVhdGluZyBaZXB0byBjb2xsZWN0aW9uc1xcbiAgLy8gcGF0Y2hhYmxlIGluIHBsdWdpbnMuXFxuICAkID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xcbiAgICByZXR1cm4gemVwdG8uaW5pdChzZWxlY3RvciwgY29udGV4dClcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSwgZGVlcCkge1xcbiAgICBmb3IgKGtleSBpbiBzb3VyY2UpXFxuICAgICAgaWYgKGRlZXAgJiYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pIHx8IGlzQXJyYXkoc291cmNlW2tleV0pKSkge1xcbiAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmICFpc1BsYWluT2JqZWN0KHRhcmdldFtrZXldKSlcXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fVxcbiAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSlcXG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBbXVxcbiAgICAgICAgZXh0ZW5kKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSwgZGVlcClcXG4gICAgICB9XFxuICAgICAgZWxzZSBpZiAoc291cmNlW2tleV0gIT09IHVuZGVmaW5lZCkgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxcbiAgfVxcblxcbiAgLy8gQ29weSBhbGwgYnV0IHVuZGVmaW5lZCBwcm9wZXJ0aWVzIGZyb20gb25lIG9yIG1vcmVcXG4gIC8vIG9iamVjdHMgdG8gdGhlIGB0YXJnZXRgIG9iamVjdC5cXG4gICQuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0KXtcXG4gICAgdmFyIGRlZXAsIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgPT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgZGVlcCA9IHRhcmdldFxcbiAgICAgIHRhcmdldCA9IGFyZ3Muc2hpZnQoKVxcbiAgICB9XFxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpeyBleHRlbmQodGFyZ2V0LCBhcmcsIGRlZXApIH0pXFxuICAgIHJldHVybiB0YXJnZXRcXG4gIH1cXG5cXG4gIC8vIGAkLnplcHRvLnFzYWAgaXMgWmVwdG8ncyBDU1Mgc2VsZWN0b3IgaW1wbGVtZW50YXRpb24gd2hpY2hcXG4gIC8vIHVzZXMgYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGxgIGFuZCBvcHRpbWl6ZXMgZm9yIHNvbWUgc3BlY2lhbCBjYXNlcywgbGlrZSBgI2lkYC5cXG4gIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIGluIHBsdWdpbnMuXFxuICB6ZXB0by5xc2EgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcil7XFxuICAgIHZhciBmb3VuZCxcXG4gICAgICAgIG1heWJlSUQgPSBzZWxlY3RvclswXSA9PSAnIycsXFxuICAgICAgICBtYXliZUNsYXNzID0gIW1heWJlSUQgJiYgc2VsZWN0b3JbMF0gPT0gJy4nLFxcbiAgICAgICAgbmFtZU9ubHkgPSBtYXliZUlEIHx8IG1heWJlQ2xhc3MgPyBzZWxlY3Rvci5zbGljZSgxKSA6IHNlbGVjdG9yLCAvLyBFbnN1cmUgdGhhdCBhIDEgY2hhciB0YWcgbmFtZSBzdGlsbCBnZXRzIGNoZWNrZWRcXG4gICAgICAgIGlzU2ltcGxlID0gc2ltcGxlU2VsZWN0b3JSRS50ZXN0KG5hbWVPbmx5KVxcbiAgICByZXR1cm4gKGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQgJiYgaXNTaW1wbGUgJiYgbWF5YmVJRCkgPyAvLyBTYWZhcmkgRG9jdW1lbnRGcmFnbWVudCBkb2Vzbid0IGhhdmUgZ2V0RWxlbWVudEJ5SWRcXG4gICAgICAoIChmb3VuZCA9IGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZU9ubHkpKSA/IFtmb3VuZF0gOiBbXSApIDpcXG4gICAgICAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSAmJiBlbGVtZW50Lm5vZGVUeXBlICE9PSA5ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IDExKSA/IFtdIDpcXG4gICAgICBzbGljZS5jYWxsKFxcbiAgICAgICAgaXNTaW1wbGUgJiYgIW1heWJlSUQgJiYgZWxlbWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID8gLy8gRG9jdW1lbnRGcmFnbWVudCBkb2Vzbid0IGhhdmUgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZS9UYWdOYW1lXFxuICAgICAgICAgIG1heWJlQ2xhc3MgPyBlbGVtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZU9ubHkpIDogLy8gSWYgaXQncyBzaW1wbGUsIGl0IGNvdWxkIGJlIGEgY2xhc3NcXG4gICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikgOiAvLyBPciBhIHRhZ1xcbiAgICAgICAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpIC8vIE9yIGl0J3Mgbm90IHNpbXBsZSwgYW5kIHdlIG5lZWQgdG8gcXVlcnkgYWxsXFxuICAgICAgKVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZmlsdGVyZWQobm9kZXMsIHNlbGVjdG9yKSB7XFxuICAgIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gJChub2RlcykgOiAkKG5vZGVzKS5maWx0ZXIoc2VsZWN0b3IpXFxuICB9XFxuXFxuICAkLmNvbnRhaW5zID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zID9cXG4gICAgZnVuY3Rpb24ocGFyZW50LCBub2RlKSB7XFxuICAgICAgcmV0dXJuIHBhcmVudCAhPT0gbm9kZSAmJiBwYXJlbnQuY29udGFpbnMobm9kZSlcXG4gICAgfSA6XFxuICAgIGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xcbiAgICAgIHdoaWxlIChub2RlICYmIChub2RlID0gbm9kZS5wYXJlbnROb2RlKSlcXG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHJldHVybiB0cnVlXFxuICAgICAgcmV0dXJuIGZhbHNlXFxuICAgIH1cXG5cXG4gIGZ1bmN0aW9uIGZ1bmNBcmcoY29udGV4dCwgYXJnLCBpZHgsIHBheWxvYWQpIHtcXG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oYXJnKSA/IGFyZy5jYWxsKGNvbnRleHQsIGlkeCwgcGF5bG9hZCkgOiBhcmdcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xcbiAgICB2YWx1ZSA9PSBudWxsID8gbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgOiBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcXG4gIH1cXG5cXG4gIC8vIGFjY2VzcyBjbGFzc05hbWUgcHJvcGVydHkgd2hpbGUgcmVzcGVjdGluZyBTVkdBbmltYXRlZFN0cmluZ1xcbiAgZnVuY3Rpb24gY2xhc3NOYW1lKG5vZGUsIHZhbHVlKXtcXG4gICAgdmFyIGtsYXNzID0gbm9kZS5jbGFzc05hbWUgfHwgJycsXFxuICAgICAgICBzdmcgICA9IGtsYXNzICYmIGtsYXNzLmJhc2VWYWwgIT09IHVuZGVmaW5lZFxcblxcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN2ZyA/IGtsYXNzLmJhc2VWYWwgOiBrbGFzc1xcbiAgICBzdmcgPyAoa2xhc3MuYmFzZVZhbCA9IHZhbHVlKSA6IChub2RlLmNsYXNzTmFtZSA9IHZhbHVlKVxcbiAgfVxcblxcbiAgLy8gXFxcInRydWVcXFwiICA9PiB0cnVlXFxuICAvLyBcXFwiZmFsc2VcXFwiID0+IGZhbHNlXFxuICAvLyBcXFwibnVsbFxcXCIgID0+IG51bGxcXG4gIC8vIFxcXCI0MlxcXCIgICAgPT4gNDJcXG4gIC8vIFxcXCI0Mi41XFxcIiAgPT4gNDIuNVxcbiAgLy8gXFxcIjA4XFxcIiAgICA9PiBcXFwiMDhcXFwiXFxuICAvLyBKU09OICAgID0+IHBhcnNlIGlmIHZhbGlkXFxuICAvLyBTdHJpbmcgID0+IHNlbGZcXG4gIGZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gdmFsdWUgP1xcbiAgICAgICAgdmFsdWUgPT0gXFxcInRydWVcXFwiIHx8XFxuICAgICAgICAoIHZhbHVlID09IFxcXCJmYWxzZVxcXCIgPyBmYWxzZSA6XFxuICAgICAgICAgIHZhbHVlID09IFxcXCJudWxsXFxcIiA/IG51bGwgOlxcbiAgICAgICAgICArdmFsdWUgKyBcXFwiXFxcIiA9PSB2YWx1ZSA/ICt2YWx1ZSA6XFxuICAgICAgICAgIC9eW1xcXFxbXFxcXHtdLy50ZXN0KHZhbHVlKSA/ICQucGFyc2VKU09OKHZhbHVlKSA6XFxuICAgICAgICAgIHZhbHVlIClcXG4gICAgICAgIDogdmFsdWVcXG4gICAgfSBjYXRjaChlKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlXFxuICAgIH1cXG4gIH1cXG5cXG4gICQudHlwZSA9IHR5cGVcXG4gICQuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb25cXG4gICQuaXNXaW5kb3cgPSBpc1dpbmRvd1xcbiAgJC5pc0FycmF5ID0gaXNBcnJheVxcbiAgJC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdFxcblxcbiAgJC5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XFxuICAgIHZhciBuYW1lXFxuICAgIGZvciAobmFtZSBpbiBvYmopIHJldHVybiBmYWxzZVxcbiAgICByZXR1cm4gdHJ1ZVxcbiAgfVxcblxcbiAgJC5pc051bWVyaWMgPSBmdW5jdGlvbih2YWwpIHtcXG4gICAgdmFyIG51bSA9IE51bWJlcih2YWwpLCB0eXBlID0gdHlwZW9mIHZhbFxcbiAgICByZXR1cm4gdmFsICE9IG51bGwgJiYgdHlwZSAhPSAnYm9vbGVhbicgJiZcXG4gICAgICAodHlwZSAhPSAnc3RyaW5nJyB8fCB2YWwubGVuZ3RoKSAmJlxcbiAgICAgICFpc05hTihudW0pICYmIGlzRmluaXRlKG51bSkgfHwgZmFsc2VcXG4gIH1cXG5cXG4gICQuaW5BcnJheSA9IGZ1bmN0aW9uKGVsZW0sIGFycmF5LCBpKXtcXG4gICAgcmV0dXJuIGVtcHR5QXJyYXkuaW5kZXhPZi5jYWxsKGFycmF5LCBlbGVtLCBpKVxcbiAgfVxcblxcbiAgJC5jYW1lbENhc2UgPSBjYW1lbGl6ZVxcbiAgJC50cmltID0gZnVuY3Rpb24oc3RyKSB7XFxuICAgIHJldHVybiBzdHIgPT0gbnVsbCA/IFxcXCJcXFwiIDogU3RyaW5nLnByb3RvdHlwZS50cmltLmNhbGwoc3RyKVxcbiAgfVxcblxcbiAgLy8gcGx1Z2luIGNvbXBhdGliaWxpdHlcXG4gICQudXVpZCA9IDBcXG4gICQuc3VwcG9ydCA9IHsgfVxcbiAgJC5leHByID0geyB9XFxuICAkLm5vb3AgPSBmdW5jdGlvbigpIHt9XFxuXFxuICAkLm1hcCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XFxuICAgIHZhciB2YWx1ZSwgdmFsdWVzID0gW10sIGksIGtleVxcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSlcXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbWVudHNbaV0sIGkpXFxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgdmFsdWVzLnB1c2godmFsdWUpXFxuICAgICAgfVxcbiAgICBlbHNlXFxuICAgICAgZm9yIChrZXkgaW4gZWxlbWVudHMpIHtcXG4gICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbWVudHNba2V5XSwga2V5KVxcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHZhbHVlcy5wdXNoKHZhbHVlKVxcbiAgICAgIH1cXG4gICAgcmV0dXJuIGZsYXR0ZW4odmFsdWVzKVxcbiAgfVxcblxcbiAgJC5lYWNoID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcXG4gICAgdmFyIGksIGtleVxcbiAgICBpZiAobGlrZUFycmF5KGVsZW1lbnRzKSkge1xcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcXG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGVsZW1lbnRzW2ldLCBpLCBlbGVtZW50c1tpXSkgPT09IGZhbHNlKSByZXR1cm4gZWxlbWVudHNcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cylcXG4gICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGVsZW1lbnRzW2tleV0sIGtleSwgZWxlbWVudHNba2V5XSkgPT09IGZhbHNlKSByZXR1cm4gZWxlbWVudHNcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZWxlbWVudHNcXG4gIH1cXG5cXG4gICQuZ3JlcCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XFxuICAgIHJldHVybiBmaWx0ZXIuY2FsbChlbGVtZW50cywgY2FsbGJhY2spXFxuICB9XFxuXFxuICBpZiAod2luZG93LkpTT04pICQucGFyc2VKU09OID0gSlNPTi5wYXJzZVxcblxcbiAgLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXFxuICAkLmVhY2goXFxcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcXFwiLnNwbGl0KFxcXCIgXFxcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcXG4gICAgY2xhc3MydHlwZVsgXFxcIltvYmplY3QgXFxcIiArIG5hbWUgKyBcXFwiXVxcXCIgXSA9IG5hbWUudG9Mb3dlckNhc2UoKVxcbiAgfSlcXG5cXG4gIC8vIERlZmluZSBtZXRob2RzIHRoYXQgd2lsbCBiZSBhdmFpbGFibGUgb24gYWxsXFxuICAvLyBaZXB0byBjb2xsZWN0aW9uc1xcbiAgJC5mbiA9IHtcXG4gICAgY29uc3RydWN0b3I6IHplcHRvLlosXFxuICAgIGxlbmd0aDogMCxcXG5cXG4gICAgLy8gQmVjYXVzZSBhIGNvbGxlY3Rpb24gYWN0cyBsaWtlIGFuIGFycmF5XFxuICAgIC8vIGNvcHkgb3ZlciB0aGVzZSB1c2VmdWwgYXJyYXkgZnVuY3Rpb25zLlxcbiAgICBmb3JFYWNoOiBlbXB0eUFycmF5LmZvckVhY2gsXFxuICAgIHJlZHVjZTogZW1wdHlBcnJheS5yZWR1Y2UsXFxuICAgIHB1c2g6IGVtcHR5QXJyYXkucHVzaCxcXG4gICAgc29ydDogZW1wdHlBcnJheS5zb3J0LFxcbiAgICBzcGxpY2U6IGVtcHR5QXJyYXkuc3BsaWNlLFxcbiAgICBpbmRleE9mOiBlbXB0eUFycmF5LmluZGV4T2YsXFxuICAgIGNvbmNhdDogZnVuY3Rpb24oKXtcXG4gICAgICB2YXIgaSwgdmFsdWUsIGFyZ3MgPSBbXVxcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIHZhbHVlID0gYXJndW1lbnRzW2ldXFxuICAgICAgICBhcmdzW2ldID0gemVwdG8uaXNaKHZhbHVlKSA/IHZhbHVlLnRvQXJyYXkoKSA6IHZhbHVlXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkoemVwdG8uaXNaKHRoaXMpID8gdGhpcy50b0FycmF5KCkgOiB0aGlzLCBhcmdzKVxcbiAgICB9LFxcblxcbiAgICAvLyBgbWFwYCBhbmQgYHNsaWNlYCBpbiB0aGUgalF1ZXJ5IEFQSSB3b3JrIGRpZmZlcmVudGx5XFxuICAgIC8vIGZyb20gdGhlaXIgYXJyYXkgY291bnRlcnBhcnRzXFxuICAgIG1hcDogZnVuY3Rpb24oZm4pe1xcbiAgICAgIHJldHVybiAkKCQubWFwKHRoaXMsIGZ1bmN0aW9uKGVsLCBpKXsgcmV0dXJuIGZuLmNhbGwoZWwsIGksIGVsKSB9KSlcXG4gICAgfSxcXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuICQoc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSlcXG4gICAgfSxcXG5cXG4gICAgcmVhZHk6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcXG4gICAgICAvLyBuZWVkIHRvIGNoZWNrIGlmIGRvY3VtZW50LmJvZHkgZXhpc3RzIGZvciBJRSBhcyB0aGF0IGJyb3dzZXIgcmVwb3J0c1xcbiAgICAgIC8vIGRvY3VtZW50IHJlYWR5IHdoZW4gaXQgaGFzbid0IHlldCBjcmVhdGVkIHRoZSBib2R5IGVsZW1lbnRcXG4gICAgICBpZiAocmVhZHlSRS50ZXN0KGRvY3VtZW50LnJlYWR5U3RhdGUpICYmIGRvY3VtZW50LmJvZHkpIGNhbGxiYWNrKCQpXFxuICAgICAgZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZnVuY3Rpb24oKXsgY2FsbGJhY2soJCkgfSwgZmFsc2UpXFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgZ2V0OiBmdW5jdGlvbihpZHgpe1xcbiAgICAgIHJldHVybiBpZHggPT09IHVuZGVmaW5lZCA/IHNsaWNlLmNhbGwodGhpcykgOiB0aGlzW2lkeCA+PSAwID8gaWR4IDogaWR4ICsgdGhpcy5sZW5ndGhdXFxuICAgIH0sXFxuICAgIHRvQXJyYXk6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmdldCgpIH0sXFxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoXFxuICAgIH0sXFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgICBpZiAodGhpcy5wYXJlbnROb2RlICE9IG51bGwpXFxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcXG4gICAgICBlbXB0eUFycmF5LmV2ZXJ5LmNhbGwodGhpcywgZnVuY3Rpb24oZWwsIGlkeCl7XFxuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChlbCwgaWR4LCBlbCkgIT09IGZhbHNlXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9LFxcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHJldHVybiB0aGlzLm5vdCh0aGlzLm5vdChzZWxlY3RvcikpXFxuICAgICAgcmV0dXJuICQoZmlsdGVyLmNhbGwodGhpcywgZnVuY3Rpb24oZWxlbWVudCl7XFxuICAgICAgICByZXR1cm4gemVwdG8ubWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcilcXG4gICAgICB9KSlcXG4gICAgfSxcXG4gICAgYWRkOiBmdW5jdGlvbihzZWxlY3Rvcixjb250ZXh0KXtcXG4gICAgICByZXR1cm4gJCh1bmlxKHRoaXMuY29uY2F0KCQoc2VsZWN0b3IsY29udGV4dCkpKSlcXG4gICAgfSxcXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPiAwICYmIHplcHRvLm1hdGNoZXModGhpc1swXSwgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIG5vdDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHZhciBub2Rlcz1bXVxcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHNlbGVjdG9yKSAmJiBzZWxlY3Rvci5jYWxsICE9PSB1bmRlZmluZWQpXFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgaWYgKCFzZWxlY3Rvci5jYWxsKHRoaXMsaWR4KSkgbm9kZXMucHVzaCh0aGlzKVxcbiAgICAgICAgfSlcXG4gICAgICBlbHNlIHtcXG4gICAgICAgIHZhciBleGNsdWRlcyA9IHR5cGVvZiBzZWxlY3RvciA9PSAnc3RyaW5nJyA/IHRoaXMuZmlsdGVyKHNlbGVjdG9yKSA6XFxuICAgICAgICAgIChsaWtlQXJyYXkoc2VsZWN0b3IpICYmIGlzRnVuY3Rpb24oc2VsZWN0b3IuaXRlbSkpID8gc2xpY2UuY2FsbChzZWxlY3RvcikgOiAkKHNlbGVjdG9yKVxcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcXG4gICAgICAgICAgaWYgKGV4Y2x1ZGVzLmluZGV4T2YoZWwpIDwgMCkgbm9kZXMucHVzaChlbClcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICAgIHJldHVybiAkKG5vZGVzKVxcbiAgICB9LFxcbiAgICBoYXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24oKXtcXG4gICAgICAgIHJldHVybiBpc09iamVjdChzZWxlY3RvcikgP1xcbiAgICAgICAgICAkLmNvbnRhaW5zKHRoaXMsIHNlbGVjdG9yKSA6XFxuICAgICAgICAgICQodGhpcykuZmluZChzZWxlY3Rvcikuc2l6ZSgpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgZXE6IGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgcmV0dXJuIGlkeCA9PT0gLTEgPyB0aGlzLnNsaWNlKGlkeCkgOiB0aGlzLnNsaWNlKGlkeCwgKyBpZHggKyAxKVxcbiAgICB9LFxcbiAgICBmaXJzdDogZnVuY3Rpb24oKXtcXG4gICAgICB2YXIgZWwgPSB0aGlzWzBdXFxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXFxuICAgIH0sXFxuICAgIGxhc3Q6IGZ1bmN0aW9uKCl7XFxuICAgICAgdmFyIGVsID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXFxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXFxuICAgIH0sXFxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICB2YXIgcmVzdWx0LCAkdGhpcyA9IHRoaXNcXG4gICAgICBpZiAoIXNlbGVjdG9yKSByZXN1bHQgPSAkKClcXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcpXFxuICAgICAgICByZXN1bHQgPSAkKHNlbGVjdG9yKS5maWx0ZXIoZnVuY3Rpb24oKXtcXG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzXFxuICAgICAgICAgIHJldHVybiBlbXB0eUFycmF5LnNvbWUuY2FsbCgkdGhpcywgZnVuY3Rpb24ocGFyZW50KXtcXG4gICAgICAgICAgICByZXR1cm4gJC5jb250YWlucyhwYXJlbnQsIG5vZGUpXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09IDEpIHJlc3VsdCA9ICQoemVwdG8ucXNhKHRoaXNbMF0sIHNlbGVjdG9yKSlcXG4gICAgICBlbHNlIHJlc3VsdCA9IHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiB6ZXB0by5xc2EodGhpcywgc2VsZWN0b3IpIH0pXFxuICAgICAgcmV0dXJuIHJlc3VsdFxcbiAgICB9LFxcbiAgICBjbG9zZXN0OiBmdW5jdGlvbihzZWxlY3RvciwgY29udGV4dCl7XFxuICAgICAgdmFyIG5vZGVzID0gW10sIGNvbGxlY3Rpb24gPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ29iamVjdCcgJiYgJChzZWxlY3RvcilcXG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oXywgbm9kZSl7XFxuICAgICAgICB3aGlsZSAobm9kZSAmJiAhKGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmluZGV4T2Yobm9kZSkgPj0gMCA6IHplcHRvLm1hdGNoZXMobm9kZSwgc2VsZWN0b3IpKSlcXG4gICAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlXFxuICAgICAgICBpZiAobm9kZSAmJiBub2Rlcy5pbmRleE9mKG5vZGUpIDwgMCkgbm9kZXMucHVzaChub2RlKVxcbiAgICAgIH0pXFxuICAgICAgcmV0dXJuICQobm9kZXMpXFxuICAgIH0sXFxuICAgIHBhcmVudHM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG5vZGVzID0gdGhpc1xcbiAgICAgIHdoaWxlIChub2Rlcy5sZW5ndGggPiAwKVxcbiAgICAgICAgbm9kZXMgPSAkLm1hcChub2RlcywgZnVuY3Rpb24obm9kZSl7XFxuICAgICAgICAgIGlmICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPCAwKSB7XFxuICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gobm9kZSlcXG4gICAgICAgICAgICByZXR1cm4gbm9kZVxcbiAgICAgICAgICB9XFxuICAgICAgICB9KVxcbiAgICAgIHJldHVybiBmaWx0ZXJlZChhbmNlc3RvcnMsIHNlbGVjdG9yKVxcbiAgICB9LFxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICByZXR1cm4gZmlsdGVyZWQodW5pcSh0aGlzLnBsdWNrKCdwYXJlbnROb2RlJykpLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgY2hpbGRyZW46IGZ1bmN0aW9uKHNlbGVjdG9yKXtcXG4gICAgICByZXR1cm4gZmlsdGVyZWQodGhpcy5tYXAoZnVuY3Rpb24oKXsgcmV0dXJuIGNoaWxkcmVuKHRoaXMpIH0pLCBzZWxlY3RvcilcXG4gICAgfSxcXG4gICAgY29udGVudHM6IGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGVudERvY3VtZW50IHx8IHNsaWNlLmNhbGwodGhpcy5jaGlsZE5vZGVzKSB9KVxcbiAgICB9LFxcbiAgICBzaWJsaW5nczogZnVuY3Rpb24oc2VsZWN0b3Ipe1xcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh0aGlzLm1hcChmdW5jdGlvbihpLCBlbCl7XFxuICAgICAgICByZXR1cm4gZmlsdGVyLmNhbGwoY2hpbGRyZW4oZWwucGFyZW50Tm9kZSksIGZ1bmN0aW9uKGNoaWxkKXsgcmV0dXJuIGNoaWxkIT09ZWwgfSlcXG4gICAgICB9KSwgc2VsZWN0b3IpXFxuICAgIH0sXFxuICAgIGVtcHR5OiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5pbm5lckhUTUwgPSAnJyB9KVxcbiAgICB9LFxcbiAgICAvLyBgcGx1Y2tgIGlzIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLmpzXFxuICAgIHBsdWNrOiBmdW5jdGlvbihwcm9wZXJ0eSl7XFxuICAgICAgcmV0dXJuICQubWFwKHRoaXMsIGZ1bmN0aW9uKGVsKXsgcmV0dXJuIGVsW3Byb3BlcnR5XSB9KVxcbiAgICB9LFxcbiAgICBzaG93OiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9PSBcXFwibm9uZVxcXCIgJiYgKHRoaXMuc3R5bGUuZGlzcGxheSA9ICcnKVxcbiAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcywgJycpLmdldFByb3BlcnR5VmFsdWUoXFxcImRpc3BsYXlcXFwiKSA9PSBcXFwibm9uZVxcXCIpXFxuICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5KHRoaXMubm9kZU5hbWUpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgcmVwbGFjZVdpdGg6IGZ1bmN0aW9uKG5ld0NvbnRlbnQpe1xcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZShuZXdDb250ZW50KS5yZW1vdmUoKVxcbiAgICB9LFxcbiAgICB3cmFwOiBmdW5jdGlvbihzdHJ1Y3R1cmUpe1xcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXFxuICAgICAgaWYgKHRoaXNbMF0gJiYgIWZ1bmMpXFxuICAgICAgICB2YXIgZG9tICAgPSAkKHN0cnVjdHVyZSkuZ2V0KDApLFxcbiAgICAgICAgICAgIGNsb25lID0gZG9tLnBhcmVudE5vZGUgfHwgdGhpcy5sZW5ndGggPiAxXFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpbmRleCl7XFxuICAgICAgICAkKHRoaXMpLndyYXBBbGwoXFxuICAgICAgICAgIGZ1bmMgPyBzdHJ1Y3R1cmUuY2FsbCh0aGlzLCBpbmRleCkgOlxcbiAgICAgICAgICAgIGNsb25lID8gZG9tLmNsb25lTm9kZSh0cnVlKSA6IGRvbVxcbiAgICAgICAgKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XFxuICAgICAgaWYgKHRoaXNbMF0pIHtcXG4gICAgICAgICQodGhpc1swXSkuYmVmb3JlKHN0cnVjdHVyZSA9ICQoc3RydWN0dXJlKSlcXG4gICAgICAgIHZhciBjaGlsZHJlblxcbiAgICAgICAgLy8gZHJpbGwgZG93biB0byB0aGUgaW5tb3N0IGVsZW1lbnRcXG4gICAgICAgIHdoaWxlICgoY2hpbGRyZW4gPSBzdHJ1Y3R1cmUuY2hpbGRyZW4oKSkubGVuZ3RoKSBzdHJ1Y3R1cmUgPSBjaGlsZHJlbi5maXJzdCgpXFxuICAgICAgICAkKHN0cnVjdHVyZSkuYXBwZW5kKHRoaXMpXFxuICAgICAgfVxcbiAgICAgIHJldHVybiB0aGlzXFxuICAgIH0sXFxuICAgIHdyYXBJbm5lcjogZnVuY3Rpb24oc3RydWN0dXJlKXtcXG4gICAgICB2YXIgZnVuYyA9IGlzRnVuY3Rpb24oc3RydWN0dXJlKVxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xcbiAgICAgICAgdmFyIHNlbGYgPSAkKHRoaXMpLCBjb250ZW50cyA9IHNlbGYuY29udGVudHMoKSxcXG4gICAgICAgICAgICBkb20gID0gZnVuYyA/IHN0cnVjdHVyZS5jYWxsKHRoaXMsIGluZGV4KSA6IHN0cnVjdHVyZVxcbiAgICAgICAgY29udGVudHMubGVuZ3RoID8gY29udGVudHMud3JhcEFsbChkb20pIDogc2VsZi5hcHBlbmQoZG9tKVxcbiAgICAgIH0pXFxuICAgIH0sXFxuICAgIHVud3JhcDogZnVuY3Rpb24oKXtcXG4gICAgICB0aGlzLnBhcmVudCgpLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAgICQodGhpcykucmVwbGFjZVdpdGgoJCh0aGlzKS5jaGlsZHJlbigpKVxcbiAgICAgIH0pXFxuICAgICAgcmV0dXJuIHRoaXNcXG4gICAgfSxcXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCl7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmNsb25lTm9kZSh0cnVlKSB9KVxcbiAgICB9LFxcbiAgICBoaWRlOiBmdW5jdGlvbigpe1xcbiAgICAgIHJldHVybiB0aGlzLmNzcyhcXFwiZGlzcGxheVxcXCIsIFxcXCJub25lXFxcIilcXG4gICAgfSxcXG4gICAgdG9nZ2xlOiBmdW5jdGlvbihzZXR0aW5nKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgICB2YXIgZWwgPSAkKHRoaXMpXFxuICAgICAgICA7KHNldHRpbmcgPT09IHVuZGVmaW5lZCA/IGVsLmNzcyhcXFwiZGlzcGxheVxcXCIpID09IFxcXCJub25lXFxcIiA6IHNldHRpbmcpID8gZWwuc2hvdygpIDogZWwuaGlkZSgpXFxuICAgICAgfSlcXG4gICAgfSxcXG4gICAgcHJldjogZnVuY3Rpb24oc2VsZWN0b3IpeyByZXR1cm4gJCh0aGlzLnBsdWNrKCdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJykpLmZpbHRlcihzZWxlY3RvciB8fCAnKicpIH0sXFxuICAgIG5leHQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXsgcmV0dXJuICQodGhpcy5wbHVjaygnbmV4dEVsZW1lbnRTaWJsaW5nJykpLmZpbHRlcihzZWxlY3RvciB8fCAnKicpIH0sXFxuICAgIGh0bWw6IGZ1bmN0aW9uKGh0bWwpe1xcbiAgICAgIHJldHVybiAwIGluIGFyZ3VtZW50cyA/XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgdmFyIG9yaWdpbkh0bWwgPSB0aGlzLmlubmVySFRNTFxcbiAgICAgICAgICAkKHRoaXMpLmVtcHR5KCkuYXBwZW5kKCBmdW5jQXJnKHRoaXMsIGh0bWwsIGlkeCwgb3JpZ2luSHRtbCkgKVxcbiAgICAgICAgfSkgOlxcbiAgICAgICAgKDAgaW4gdGhpcyA/IHRoaXNbMF0uaW5uZXJIVE1MIDogbnVsbClcXG4gICAgfSxcXG4gICAgdGV4dDogZnVuY3Rpb24odGV4dCl7XFxuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZ1bmNBcmcodGhpcywgdGV4dCwgaWR4LCB0aGlzLnRleHRDb250ZW50KVxcbiAgICAgICAgICB0aGlzLnRleHRDb250ZW50ID0gbmV3VGV4dCA9PSBudWxsID8gJycgOiAnJytuZXdUZXh0XFxuICAgICAgICB9KSA6XFxuICAgICAgICAoMCBpbiB0aGlzID8gdGhpcy5wbHVjaygndGV4dENvbnRlbnQnKS5qb2luKFxcXCJcXFwiKSA6IG51bGwpXFxuICAgIH0sXFxuICAgIGF0dHI6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKXtcXG4gICAgICB2YXIgcmVzdWx0XFxuICAgICAgcmV0dXJuICh0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyAmJiAhKDEgaW4gYXJndW1lbnRzKSkgP1xcbiAgICAgICAgKDAgaW4gdGhpcyAmJiB0aGlzWzBdLm5vZGVUeXBlID09IDEgJiYgKHJlc3VsdCA9IHRoaXNbMF0uZ2V0QXR0cmlidXRlKG5hbWUpKSAhPSBudWxsID8gcmVzdWx0IDogdW5kZWZpbmVkKSA6XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgIT09IDEpIHJldHVyblxcbiAgICAgICAgICBpZiAoaXNPYmplY3QobmFtZSkpIGZvciAoa2V5IGluIG5hbWUpIHNldEF0dHJpYnV0ZSh0aGlzLCBrZXksIG5hbWVba2V5XSlcXG4gICAgICAgICAgZWxzZSBzZXRBdHRyaWJ1dGUodGhpcywgbmFtZSwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSkpXFxuICAgICAgICB9KVxcbiAgICB9LFxcbiAgICByZW1vdmVBdHRyOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMubm9kZVR5cGUgPT09IDEgJiYgbmFtZS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24oYXR0cmlidXRlKXtcXG4gICAgICAgIHNldEF0dHJpYnV0ZSh0aGlzLCBhdHRyaWJ1dGUpXFxuICAgICAgfSwgdGhpcyl9KVxcbiAgICB9LFxcbiAgICBwcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XFxuICAgICAgbmFtZSA9IHByb3BNYXBbbmFtZV0gfHwgbmFtZVxcbiAgICAgIHJldHVybiAoMSBpbiBhcmd1bWVudHMpID9cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgICB0aGlzW25hbWVdID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzW25hbWVdKVxcbiAgICAgICAgfSkgOlxcbiAgICAgICAgKHRoaXNbMF0gJiYgdGhpc1swXVtuYW1lXSlcXG4gICAgfSxcXG4gICAgcmVtb3ZlUHJvcDogZnVuY3Rpb24obmFtZSl7XFxuICAgICAgbmFtZSA9IHByb3BNYXBbbmFtZV0gfHwgbmFtZVxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgZGVsZXRlIHRoaXNbbmFtZV0gfSlcXG4gICAgfSxcXG4gICAgZGF0YTogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xcbiAgICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBuYW1lLnJlcGxhY2UoY2FwaXRhbFJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxcblxcbiAgICAgIHZhciBkYXRhID0gKDEgaW4gYXJndW1lbnRzKSA/XFxuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUsIHZhbHVlKSA6XFxuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUpXFxuXFxuICAgICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkZXNlcmlhbGl6ZVZhbHVlKGRhdGEpIDogdW5kZWZpbmVkXFxuICAgIH0sXFxuICAgIHZhbDogZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIGlmICgwIGluIGFyZ3VtZW50cykge1xcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHZhbHVlID0gXFxcIlxcXCJcXG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgICAgdGhpcy52YWx1ZSA9IGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgdGhpcy52YWx1ZSlcXG4gICAgICAgIH0pXFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHJldHVybiB0aGlzWzBdICYmICh0aGlzWzBdLm11bHRpcGxlID9cXG4gICAgICAgICAgICQodGhpc1swXSkuZmluZCgnb3B0aW9uJykuZmlsdGVyKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnNlbGVjdGVkIH0pLnBsdWNrKCd2YWx1ZScpIDpcXG4gICAgICAgICAgIHRoaXNbMF0udmFsdWUpXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBvZmZzZXQ6IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKXtcXG4gICAgICBpZiAoY29vcmRpbmF0ZXMpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcXG4gICAgICAgICAgICBjb29yZHMgPSBmdW5jQXJnKHRoaXMsIGNvb3JkaW5hdGVzLCBpbmRleCwgJHRoaXMub2Zmc2V0KCkpLFxcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9ICR0aGlzLm9mZnNldFBhcmVudCgpLm9mZnNldCgpLFxcbiAgICAgICAgICAgIHByb3BzID0ge1xcbiAgICAgICAgICAgICAgdG9wOiAgY29vcmRzLnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxcbiAgICAgICAgICAgICAgbGVmdDogY29vcmRzLmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgIGlmICgkdGhpcy5jc3MoJ3Bvc2l0aW9uJykgPT0gJ3N0YXRpYycpIHByb3BzWydwb3NpdGlvbiddID0gJ3JlbGF0aXZlJ1xcbiAgICAgICAgJHRoaXMuY3NzKHByb3BzKVxcbiAgICAgIH0pXFxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIG51bGxcXG4gICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICE9PSB0aGlzWzBdICYmICEkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgdGhpc1swXSkpXFxuICAgICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogMH1cXG4gICAgICB2YXIgb2JqID0gdGhpc1swXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBsZWZ0OiBvYmoubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcXG4gICAgICAgIHRvcDogb2JqLnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG9iai53aWR0aCksXFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQob2JqLmhlaWdodClcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIGNzczogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1swXVxcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAoIWVsZW1lbnQpIHJldHVyblxcbiAgICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wZXJ0eSldIHx8IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgJycpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpXFxuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XFxuICAgICAgICAgIGlmICghZWxlbWVudCkgcmV0dXJuXFxuICAgICAgICAgIHZhciBwcm9wcyA9IHt9XFxuICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcXG4gICAgICAgICAgJC5lYWNoKHByb3BlcnR5LCBmdW5jdGlvbihfLCBwcm9wKXtcXG4gICAgICAgICAgICBwcm9wc1twcm9wXSA9IChlbGVtZW50LnN0eWxlW2NhbWVsaXplKHByb3ApXSB8fCBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCkpXFxuICAgICAgICAgIH0pXFxuICAgICAgICAgIHJldHVybiBwcm9wc1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgY3NzID0gJydcXG4gICAgICBpZiAodHlwZShwcm9wZXJ0eSkgPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApXFxuICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShwcm9wZXJ0eSkpIH0pXFxuICAgICAgICBlbHNlXFxuICAgICAgICAgIGNzcyA9IGRhc2hlcml6ZShwcm9wZXJ0eSkgKyBcXFwiOlxcXCIgKyBtYXliZUFkZFB4KHByb3BlcnR5LCB2YWx1ZSlcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZm9yIChrZXkgaW4gcHJvcGVydHkpXFxuICAgICAgICAgIGlmICghcHJvcGVydHlba2V5XSAmJiBwcm9wZXJ0eVtrZXldICE9PSAwKVxcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShrZXkpKSB9KVxcbiAgICAgICAgICBlbHNlXFxuICAgICAgICAgICAgY3NzICs9IGRhc2hlcml6ZShrZXkpICsgJzonICsgbWF5YmVBZGRQeChrZXksIHByb3BlcnR5W2tleV0pICsgJzsnXFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5jc3NUZXh0ICs9ICc7JyArIGNzcyB9KVxcbiAgICB9LFxcbiAgICBpbmRleDogZnVuY3Rpb24oZWxlbWVudCl7XFxuICAgICAgcmV0dXJuIGVsZW1lbnQgPyB0aGlzLmluZGV4T2YoJChlbGVtZW50KVswXSkgOiB0aGlzLnBhcmVudCgpLmNoaWxkcmVuKCkuaW5kZXhPZih0aGlzWzBdKVxcbiAgICB9LFxcbiAgICBoYXNDbGFzczogZnVuY3Rpb24obmFtZSl7XFxuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gZmFsc2VcXG4gICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwodGhpcywgZnVuY3Rpb24oZWwpe1xcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdChjbGFzc05hbWUoZWwpKVxcbiAgICAgIH0sIGNsYXNzUkUobmFtZSkpXFxuICAgIH0sXFxuICAgIGFkZENsYXNzOiBmdW5jdGlvbihuYW1lKXtcXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiB0aGlzXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgaWYgKCEoJ2NsYXNzTmFtZScgaW4gdGhpcykpIHJldHVyblxcbiAgICAgICAgY2xhc3NMaXN0ID0gW11cXG4gICAgICAgIHZhciBjbHMgPSBjbGFzc05hbWUodGhpcyksIG5ld05hbWUgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xzKVxcbiAgICAgICAgbmV3TmFtZS5zcGxpdCgvXFxcXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xcbiAgICAgICAgICBpZiAoISQodGhpcykuaGFzQ2xhc3Moa2xhc3MpKSBjbGFzc0xpc3QucHVzaChrbGFzcylcXG4gICAgICAgIH0sIHRoaXMpXFxuICAgICAgICBjbGFzc0xpc3QubGVuZ3RoICYmIGNsYXNzTmFtZSh0aGlzLCBjbHMgKyAoY2xzID8gXFxcIiBcXFwiIDogXFxcIlxcXCIpICsgY2xhc3NMaXN0LmpvaW4oXFxcIiBcXFwiKSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICByZW1vdmVDbGFzczogZnVuY3Rpb24obmFtZSl7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xcbiAgICAgICAgaWYgKCEoJ2NsYXNzTmFtZScgaW4gdGhpcykpIHJldHVyblxcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNsYXNzTmFtZSh0aGlzLCAnJylcXG4gICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTmFtZSh0aGlzKVxcbiAgICAgICAgZnVuY0FyZyh0aGlzLCBuYW1lLCBpZHgsIGNsYXNzTGlzdCkuc3BsaXQoL1xcXFxzKy9nKS5mb3JFYWNoKGZ1bmN0aW9uKGtsYXNzKXtcXG4gICAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnJlcGxhY2UoY2xhc3NSRShrbGFzcyksIFxcXCIgXFxcIilcXG4gICAgICAgIH0pXFxuICAgICAgICBjbGFzc05hbWUodGhpcywgY2xhc3NMaXN0LnRyaW0oKSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24obmFtZSwgd2hlbil7XFxuICAgICAgaWYgKCFuYW1lKSByZXR1cm4gdGhpc1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIG5hbWVzID0gZnVuY0FyZyh0aGlzLCBuYW1lLCBpZHgsIGNsYXNzTmFtZSh0aGlzKSlcXG4gICAgICAgIG5hbWVzLnNwbGl0KC9cXFxccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XFxuICAgICAgICAgICh3aGVuID09PSB1bmRlZmluZWQgPyAhJHRoaXMuaGFzQ2xhc3Moa2xhc3MpIDogd2hlbikgP1xcbiAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKGtsYXNzKSA6ICR0aGlzLnJlbW92ZUNsYXNzKGtsYXNzKVxcbiAgICAgICAgfSlcXG4gICAgICB9KVxcbiAgICB9LFxcbiAgICBzY3JvbGxUb3A6IGZ1bmN0aW9uKHZhbHVlKXtcXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cXG4gICAgICB2YXIgaGFzU2Nyb2xsVG9wID0gJ3Njcm9sbFRvcCcgaW4gdGhpc1swXVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsVG9wID8gdGhpc1swXS5zY3JvbGxUb3AgOiB0aGlzWzBdLnBhZ2VZT2Zmc2V0XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxUb3AgP1xcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxUb3AgPSB2YWx1ZSB9IDpcXG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsVG8odGhpcy5zY3JvbGxYLCB2YWx1ZSkgfSlcXG4gICAgfSxcXG4gICAgc2Nyb2xsTGVmdDogZnVuY3Rpb24odmFsdWUpe1xcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxcbiAgICAgIHZhciBoYXNTY3JvbGxMZWZ0ID0gJ3Njcm9sbExlZnQnIGluIHRoaXNbMF1cXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGhhc1Njcm9sbExlZnQgPyB0aGlzWzBdLnNjcm9sbExlZnQgOiB0aGlzWzBdLnBhZ2VYT2Zmc2V0XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxMZWZ0ID9cXG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsTGVmdCA9IHZhbHVlIH0gOlxcbiAgICAgICAgZnVuY3Rpb24oKXsgdGhpcy5zY3JvbGxUbyh2YWx1ZSwgdGhpcy5zY3JvbGxZKSB9KVxcbiAgICB9LFxcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XFxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXFxuXFxuICAgICAgdmFyIGVsZW0gPSB0aGlzWzBdLFxcbiAgICAgICAgLy8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcXG4gICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXFxuICAgICAgICAvLyBHZXQgY29ycmVjdCBvZmZzZXRzXFxuICAgICAgICBvZmZzZXQgICAgICAgPSB0aGlzLm9mZnNldCgpLFxcbiAgICAgICAgcGFyZW50T2Zmc2V0ID0gcm9vdE5vZGVSRS50ZXN0KG9mZnNldFBhcmVudFswXS5ub2RlTmFtZSkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogb2Zmc2V0UGFyZW50Lm9mZnNldCgpXFxuXFxuICAgICAgLy8gU3VidHJhY3QgZWxlbWVudCBtYXJnaW5zXFxuICAgICAgLy8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcXG4gICAgICAvLyBhcmUgdGhlIHNhbWUgaW4gU2FmYXJpIGNhdXNpbmcgb2Zmc2V0LmxlZnQgdG8gaW5jb3JyZWN0bHkgYmUgMFxcbiAgICAgIG9mZnNldC50b3AgIC09IHBhcnNlRmxvYXQoICQoZWxlbSkuY3NzKCdtYXJnaW4tdG9wJykgKSB8fCAwXFxuICAgICAgb2Zmc2V0LmxlZnQgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi1sZWZ0JykgKSB8fCAwXFxuXFxuICAgICAgLy8gQWRkIG9mZnNldFBhcmVudCBib3JkZXJzXFxuICAgICAgcGFyZW50T2Zmc2V0LnRvcCAgKz0gcGFyc2VGbG9hdCggJChvZmZzZXRQYXJlbnRbMF0pLmNzcygnYm9yZGVyLXRvcC13aWR0aCcpICkgfHwgMFxcbiAgICAgIHBhcmVudE9mZnNldC5sZWZ0ICs9IHBhcnNlRmxvYXQoICQob2Zmc2V0UGFyZW50WzBdKS5jc3MoJ2JvcmRlci1sZWZ0LXdpZHRoJykgKSB8fCAwXFxuXFxuICAgICAgLy8gU3VidHJhY3QgdGhlIHR3byBvZmZzZXRzXFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHRvcDogIG9mZnNldC50b3AgIC0gcGFyZW50T2Zmc2V0LnRvcCxcXG4gICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcXG4gICAgICB9XFxuICAgIH0sXFxuICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCl7XFxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnQuYm9keVxcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhcm9vdE5vZGVSRS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgJChwYXJlbnQpLmNzcyhcXFwicG9zaXRpb25cXFwiKSA9PSBcXFwic3RhdGljXFxcIilcXG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm9mZnNldFBhcmVudFxcbiAgICAgICAgcmV0dXJuIHBhcmVudFxcbiAgICAgIH0pXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGZvciBub3dcXG4gICQuZm4uZGV0YWNoID0gJC5mbi5yZW1vdmVcXG5cXG4gIC8vIEdlbmVyYXRlIHRoZSBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBmdW5jdGlvbnNcXG4gIDtbJ3dpZHRoJywgJ2hlaWdodCddLmZvckVhY2goZnVuY3Rpb24oZGltZW5zaW9uKXtcXG4gICAgdmFyIGRpbWVuc2lvblByb3BlcnR5ID1cXG4gICAgICBkaW1lbnNpb24ucmVwbGFjZSgvLi8sIGZ1bmN0aW9uKG0peyByZXR1cm4gbVswXS50b1VwcGVyQ2FzZSgpIH0pXFxuXFxuICAgICQuZm5bZGltZW5zaW9uXSA9IGZ1bmN0aW9uKHZhbHVlKXtcXG4gICAgICB2YXIgb2Zmc2V0LCBlbCA9IHRoaXNbMF1cXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzV2luZG93KGVsKSA/IGVsWydpbm5lcicgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxcbiAgICAgICAgaXNEb2N1bWVudChlbCkgPyBlbC5kb2N1bWVudEVsZW1lbnRbJ3Njcm9sbCcgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxcbiAgICAgICAgKG9mZnNldCA9IHRoaXMub2Zmc2V0KCkpICYmIG9mZnNldFtkaW1lbnNpb25dXFxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XFxuICAgICAgICBlbCA9ICQodGhpcylcXG4gICAgICAgIGVsLmNzcyhkaW1lbnNpb24sIGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgZWxbZGltZW5zaW9uXSgpKSlcXG4gICAgICB9KVxcbiAgICB9XFxuICB9KVxcblxcbiAgZnVuY3Rpb24gdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bikge1xcbiAgICBmdW4obm9kZSlcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcXG4gICAgICB0cmF2ZXJzZU5vZGUobm9kZS5jaGlsZE5vZGVzW2ldLCBmdW4pXFxuICB9XFxuXFxuICAvLyBHZW5lcmF0ZSB0aGUgYGFmdGVyYCwgYHByZXBlbmRgLCBgYmVmb3JlYCwgYGFwcGVuZGAsXFxuICAvLyBgaW5zZXJ0QWZ0ZXJgLCBgaW5zZXJ0QmVmb3JlYCwgYGFwcGVuZFRvYCwgYW5kIGBwcmVwZW5kVG9gIG1ldGhvZHMuXFxuICBhZGphY2VuY3lPcGVyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvciwgb3BlcmF0b3JJbmRleCkge1xcbiAgICB2YXIgaW5zaWRlID0gb3BlcmF0b3JJbmRleCAlIDIgLy89PiBwcmVwZW5kLCBhcHBlbmRcXG5cXG4gICAgJC5mbltvcGVyYXRvcl0gPSBmdW5jdGlvbigpe1xcbiAgICAgIC8vIGFyZ3VtZW50cyBjYW4gYmUgbm9kZXMsIGFycmF5cyBvZiBub2RlcywgWmVwdG8gb2JqZWN0cyBhbmQgSFRNTCBzdHJpbmdzXFxuICAgICAgdmFyIGFyZ1R5cGUsIG5vZGVzID0gJC5tYXAoYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcXG4gICAgICAgICAgICB2YXIgYXJyID0gW11cXG4gICAgICAgICAgICBhcmdUeXBlID0gdHlwZShhcmcpXFxuICAgICAgICAgICAgaWYgKGFyZ1R5cGUgPT0gXFxcImFycmF5XFxcIikge1xcbiAgICAgICAgICAgICAgYXJnLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcXG4gICAgICAgICAgICAgICAgaWYgKGVsLm5vZGVUeXBlICE9PSB1bmRlZmluZWQpIHJldHVybiBhcnIucHVzaChlbClcXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJC56ZXB0by5pc1ooZWwpKSByZXR1cm4gYXJyID0gYXJyLmNvbmNhdChlbC5nZXQoKSlcXG4gICAgICAgICAgICAgICAgYXJyID0gYXJyLmNvbmNhdCh6ZXB0by5mcmFnbWVudChlbCkpXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgICAgcmV0dXJuIGFyclxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PSBcXFwib2JqZWN0XFxcIiB8fCBhcmcgPT0gbnVsbCA/XFxuICAgICAgICAgICAgICBhcmcgOiB6ZXB0by5mcmFnbWVudChhcmcpXFxuICAgICAgICAgIH0pLFxcbiAgICAgICAgICBwYXJlbnQsIGNvcHlCeUNsb25lID0gdGhpcy5sZW5ndGggPiAxXFxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA8IDEpIHJldHVybiB0aGlzXFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihfLCB0YXJnZXQpe1xcbiAgICAgICAgcGFyZW50ID0gaW5zaWRlID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGVcXG5cXG4gICAgICAgIC8vIGNvbnZlcnQgYWxsIG1ldGhvZHMgdG8gYSBcXFwiYmVmb3JlXFxcIiBvcGVyYXRpb25cXG4gICAgICAgIHRhcmdldCA9IG9wZXJhdG9ySW5kZXggPT0gMCA/IHRhcmdldC5uZXh0U2libGluZyA6XFxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDEgPyB0YXJnZXQuZmlyc3RDaGlsZCA6XFxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDIgPyB0YXJnZXQgOlxcbiAgICAgICAgICAgICAgICAgbnVsbFxcblxcbiAgICAgICAgdmFyIHBhcmVudEluRG9jdW1lbnQgPSAkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgcGFyZW50KVxcblxcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihub2RlKXtcXG4gICAgICAgICAgaWYgKGNvcHlCeUNsb25lKSBub2RlID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcXG4gICAgICAgICAgZWxzZSBpZiAoIXBhcmVudCkgcmV0dXJuICQobm9kZSkucmVtb3ZlKClcXG5cXG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQpXFxuICAgICAgICAgIGlmIChwYXJlbnRJbkRvY3VtZW50KSB0cmF2ZXJzZU5vZGUobm9kZSwgZnVuY3Rpb24oZWwpe1xcbiAgICAgICAgICAgIGlmIChlbC5ub2RlTmFtZSAhPSBudWxsICYmIGVsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTQ1JJUFQnICYmXFxuICAgICAgICAgICAgICAgKCFlbC50eXBlIHx8IGVsLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnKSAmJiAhZWwuc3JjKXtcXG4gICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBlbC5vd25lckRvY3VtZW50ID8gZWwub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvd1xcbiAgICAgICAgICAgICAgdGFyZ2V0WydldmFsJ10uY2FsbCh0YXJnZXQsIGVsLmlubmVySFRNTClcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pXFxuICAgICAgICB9KVxcbiAgICAgIH0pXFxuICAgIH1cXG5cXG4gICAgLy8gYWZ0ZXIgICAgPT4gaW5zZXJ0QWZ0ZXJcXG4gICAgLy8gcHJlcGVuZCAgPT4gcHJlcGVuZFRvXFxuICAgIC8vIGJlZm9yZSAgID0+IGluc2VydEJlZm9yZVxcbiAgICAvLyBhcHBlbmQgICA9PiBhcHBlbmRUb1xcbiAgICAkLmZuW2luc2lkZSA/IG9wZXJhdG9yKydUbycgOiAnaW5zZXJ0Jysob3BlcmF0b3JJbmRleCA/ICdCZWZvcmUnIDogJ0FmdGVyJyldID0gZnVuY3Rpb24oaHRtbCl7XFxuICAgICAgJChodG1sKVtvcGVyYXRvcl0odGhpcylcXG4gICAgICByZXR1cm4gdGhpc1xcbiAgICB9XFxuICB9KVxcblxcbiAgemVwdG8uWi5wcm90b3R5cGUgPSBaLnByb3RvdHlwZSA9ICQuZm5cXG5cXG4gIC8vIEV4cG9ydCBpbnRlcm5hbCBBUEkgZnVuY3Rpb25zIGluIHRoZSBgJC56ZXB0b2AgbmFtZXNwYWNlXFxuICB6ZXB0by51bmlxID0gdW5pcVxcbiAgemVwdG8uZGVzZXJpYWxpemVWYWx1ZSA9IGRlc2VyaWFsaXplVmFsdWVcXG4gICQuemVwdG8gPSB6ZXB0b1xcblxcbiAgcmV0dXJuICRcXG59KSgpXFxuXFxud2luZG93LlplcHRvID0gWmVwdG9cXG53aW5kb3cuJCA9PT0gdW5kZWZpbmVkICYmICh3aW5kb3cuJCA9IFplcHRvKVxcblxcbjsoZnVuY3Rpb24oJCl7XFxuICB2YXIgX3ppZCA9IDEsIHVuZGVmaW5lZCxcXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcXG4gICAgICBpc0Z1bmN0aW9uID0gJC5pc0Z1bmN0aW9uLFxcbiAgICAgIGlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKXsgcmV0dXJuIHR5cGVvZiBvYmogPT0gJ3N0cmluZycgfSxcXG4gICAgICBoYW5kbGVycyA9IHt9LFxcbiAgICAgIHNwZWNpYWxFdmVudHM9e30sXFxuICAgICAgZm9jdXNpblN1cHBvcnRlZCA9ICdvbmZvY3VzaW4nIGluIHdpbmRvdyxcXG4gICAgICBmb2N1cyA9IHsgZm9jdXM6ICdmb2N1c2luJywgYmx1cjogJ2ZvY3Vzb3V0JyB9LFxcbiAgICAgIGhvdmVyID0geyBtb3VzZWVudGVyOiAnbW91c2VvdmVyJywgbW91c2VsZWF2ZTogJ21vdXNlb3V0JyB9XFxuXFxuICBzcGVjaWFsRXZlbnRzLmNsaWNrID0gc3BlY2lhbEV2ZW50cy5tb3VzZWRvd24gPSBzcGVjaWFsRXZlbnRzLm1vdXNldXAgPSBzcGVjaWFsRXZlbnRzLm1vdXNlbW92ZSA9ICdNb3VzZUV2ZW50cydcXG5cXG4gIGZ1bmN0aW9uIHppZChlbGVtZW50KSB7XFxuICAgIHJldHVybiBlbGVtZW50Ll96aWQgfHwgKGVsZW1lbnQuX3ppZCA9IF96aWQrKylcXG4gIH1cXG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKSB7XFxuICAgIGV2ZW50ID0gcGFyc2UoZXZlbnQpXFxuICAgIGlmIChldmVudC5ucykgdmFyIG1hdGNoZXIgPSBtYXRjaGVyRm9yKGV2ZW50Lm5zKVxcbiAgICByZXR1cm4gKGhhbmRsZXJzW3ppZChlbGVtZW50KV0gfHwgW10pLmZpbHRlcihmdW5jdGlvbihoYW5kbGVyKSB7XFxuICAgICAgcmV0dXJuIGhhbmRsZXJcXG4gICAgICAgICYmICghZXZlbnQuZSAgfHwgaGFuZGxlci5lID09IGV2ZW50LmUpXFxuICAgICAgICAmJiAoIWV2ZW50Lm5zIHx8IG1hdGNoZXIudGVzdChoYW5kbGVyLm5zKSlcXG4gICAgICAgICYmICghZm4gICAgICAgfHwgemlkKGhhbmRsZXIuZm4pID09PSB6aWQoZm4pKVxcbiAgICAgICAgJiYgKCFzZWxlY3RvciB8fCBoYW5kbGVyLnNlbCA9PSBzZWxlY3RvcilcXG4gICAgfSlcXG4gIH1cXG4gIGZ1bmN0aW9uIHBhcnNlKGV2ZW50KSB7XFxuICAgIHZhciBwYXJ0cyA9ICgnJyArIGV2ZW50KS5zcGxpdCgnLicpXFxuICAgIHJldHVybiB7ZTogcGFydHNbMF0sIG5zOiBwYXJ0cy5zbGljZSgxKS5zb3J0KCkuam9pbignICcpfVxcbiAgfVxcbiAgZnVuY3Rpb24gbWF0Y2hlckZvcihucykge1xcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnwgKScgKyBucy5yZXBsYWNlKCcgJywgJyAuKiA/JykgKyAnKD86IHwkKScpXFxuICB9XFxuXFxuICBmdW5jdGlvbiBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZVNldHRpbmcpIHtcXG4gICAgcmV0dXJuIGhhbmRsZXIuZGVsICYmXFxuICAgICAgKCFmb2N1c2luU3VwcG9ydGVkICYmIChoYW5kbGVyLmUgaW4gZm9jdXMpKSB8fFxcbiAgICAgICEhY2FwdHVyZVNldHRpbmdcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWxFdmVudCh0eXBlKSB7XFxuICAgIHJldHVybiBob3Zlclt0eXBlXSB8fCAoZm9jdXNpblN1cHBvcnRlZCAmJiBmb2N1c1t0eXBlXSkgfHwgdHlwZVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkKGVsZW1lbnQsIGV2ZW50cywgZm4sIGRhdGEsIHNlbGVjdG9yLCBkZWxlZ2F0b3IsIGNhcHR1cmUpe1xcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudCksIHNldCA9IChoYW5kbGVyc1tpZF0gfHwgKGhhbmRsZXJzW2lkXSA9IFtdKSlcXG4gICAgZXZlbnRzLnNwbGl0KC9cXFxccy8pLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpe1xcbiAgICAgIGlmIChldmVudCA9PSAncmVhZHknKSByZXR1cm4gJChkb2N1bWVudCkucmVhZHkoZm4pXFxuICAgICAgdmFyIGhhbmRsZXIgICA9IHBhcnNlKGV2ZW50KVxcbiAgICAgIGhhbmRsZXIuZm4gICAgPSBmblxcbiAgICAgIGhhbmRsZXIuc2VsICAgPSBzZWxlY3RvclxcbiAgICAgIC8vIGVtdWxhdGUgbW91c2VlbnRlciwgbW91c2VsZWF2ZVxcbiAgICAgIGlmIChoYW5kbGVyLmUgaW4gaG92ZXIpIGZuID0gZnVuY3Rpb24oZSl7XFxuICAgICAgICB2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldFxcbiAgICAgICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEkLmNvbnRhaW5zKHRoaXMsIHJlbGF0ZWQpKSlcXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIuZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxcbiAgICAgIH1cXG4gICAgICBoYW5kbGVyLmRlbCAgID0gZGVsZWdhdG9yXFxuICAgICAgdmFyIGNhbGxiYWNrICA9IGRlbGVnYXRvciB8fCBmblxcbiAgICAgIGhhbmRsZXIucHJveHkgPSBmdW5jdGlvbihlKXtcXG4gICAgICAgIGUgPSBjb21wYXRpYmxlKGUpXFxuICAgICAgICBpZiAoZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm5cXG4gICAgICAgIGUuZGF0YSA9IGRhdGFcXG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjay5hcHBseShlbGVtZW50LCBlLl9hcmdzID09IHVuZGVmaW5lZCA/IFtlXSA6IFtlXS5jb25jYXQoZS5fYXJncykpXFxuICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkgZS5wcmV2ZW50RGVmYXVsdCgpLCBlLnN0b3BQcm9wYWdhdGlvbigpXFxuICAgICAgICByZXR1cm4gcmVzdWx0XFxuICAgICAgfVxcbiAgICAgIGhhbmRsZXIuaSA9IHNldC5sZW5ndGhcXG4gICAgICBzZXQucHVzaChoYW5kbGVyKVxcbiAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudClcXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihyZWFsRXZlbnQoaGFuZGxlci5lKSwgaGFuZGxlci5wcm94eSwgZXZlbnRDYXB0dXJlKGhhbmRsZXIsIGNhcHR1cmUpKVxcbiAgICB9KVxcbiAgfVxcbiAgZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQsIGV2ZW50cywgZm4sIHNlbGVjdG9yLCBjYXB0dXJlKXtcXG4gICAgdmFyIGlkID0gemlkKGVsZW1lbnQpXFxuICAgIDsoZXZlbnRzIHx8ICcnKS5zcGxpdCgvXFxcXHMvKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcXG4gICAgICBmaW5kSGFuZGxlcnMoZWxlbWVudCwgZXZlbnQsIGZuLCBzZWxlY3RvcikuZm9yRWFjaChmdW5jdGlvbihoYW5kbGVyKXtcXG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tpZF1baGFuZGxlci5pXVxcbiAgICAgIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudClcXG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihyZWFsRXZlbnQoaGFuZGxlci5lKSwgaGFuZGxlci5wcm94eSwgZXZlbnRDYXB0dXJlKGhhbmRsZXIsIGNhcHR1cmUpKVxcbiAgICAgIH0pXFxuICAgIH0pXFxuICB9XFxuXFxuICAkLmV2ZW50ID0geyBhZGQ6IGFkZCwgcmVtb3ZlOiByZW1vdmUgfVxcblxcbiAgJC5wcm94eSA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XFxuICAgIHZhciBhcmdzID0gKDIgaW4gYXJndW1lbnRzKSAmJiBzbGljZS5jYWxsKGFyZ3VtZW50cywgMilcXG4gICAgaWYgKGlzRnVuY3Rpb24oZm4pKSB7XFxuICAgICAgdmFyIHByb3h5Rm4gPSBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpIH1cXG4gICAgICBwcm94eUZuLl96aWQgPSB6aWQoZm4pXFxuICAgICAgcmV0dXJuIHByb3h5Rm5cXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb250ZXh0KSkge1xcbiAgICAgIGlmIChhcmdzKSB7XFxuICAgICAgICBhcmdzLnVuc2hpZnQoZm5bY29udGV4dF0sIGZuKVxcbiAgICAgICAgcmV0dXJuICQucHJveHkuYXBwbHkobnVsbCwgYXJncylcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuICQucHJveHkoZm5bY29udGV4dF0sIGZuKVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJleHBlY3RlZCBmdW5jdGlvblxcXCIpXFxuICAgIH1cXG4gIH1cXG5cXG4gICQuZm4uYmluZCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhLCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhLCBjYWxsYmFjaylcXG4gIH1cXG4gICQuZm4udW5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBjYWxsYmFjaylcXG4gIH1cXG4gICQuZm4ub25lID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBkYXRhLCBjYWxsYmFjayl7XFxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2ssIDEpXFxuICB9XFxuXFxuICB2YXIgcmV0dXJuVHJ1ZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHRydWV9LFxcbiAgICAgIHJldHVybkZhbHNlID0gZnVuY3Rpb24oKXtyZXR1cm4gZmFsc2V9LFxcbiAgICAgIGlnbm9yZVByb3BlcnRpZXMgPSAvXihbQS1aXXxyZXR1cm5WYWx1ZSR8bGF5ZXJbWFldJHx3ZWJraXRNb3ZlbWVudFtYWV0kKS8sXFxuICAgICAgZXZlbnRNZXRob2RzID0ge1xcbiAgICAgICAgcHJldmVudERlZmF1bHQ6ICdpc0RlZmF1bHRQcmV2ZW50ZWQnLFxcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiAnaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQnLFxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAnaXNQcm9wYWdhdGlvblN0b3BwZWQnXFxuICAgICAgfVxcblxcbiAgZnVuY3Rpb24gY29tcGF0aWJsZShldmVudCwgc291cmNlKSB7XFxuICAgIGlmIChzb3VyY2UgfHwgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgIHNvdXJjZSB8fCAoc291cmNlID0gZXZlbnQpXFxuXFxuICAgICAgJC5lYWNoKGV2ZW50TWV0aG9kcywgZnVuY3Rpb24obmFtZSwgcHJlZGljYXRlKSB7XFxuICAgICAgICB2YXIgc291cmNlTWV0aG9kID0gc291cmNlW25hbWVdXFxuICAgICAgICBldmVudFtuYW1lXSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgICAgIHRoaXNbcHJlZGljYXRlXSA9IHJldHVyblRydWVcXG4gICAgICAgICAgcmV0dXJuIHNvdXJjZU1ldGhvZCAmJiBzb3VyY2VNZXRob2QuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpXFxuICAgICAgICB9XFxuICAgICAgICBldmVudFtwcmVkaWNhdGVdID0gcmV0dXJuRmFsc2VcXG4gICAgICB9KVxcblxcbiAgICAgIGV2ZW50LnRpbWVTdGFtcCB8fCAoZXZlbnQudGltZVN0YW1wID0gRGF0ZS5ub3coKSlcXG5cXG4gICAgICBpZiAoc291cmNlLmRlZmF1bHRQcmV2ZW50ZWQgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5kZWZhdWx0UHJldmVudGVkIDpcXG4gICAgICAgICAgJ3JldHVyblZhbHVlJyBpbiBzb3VyY2UgPyBzb3VyY2UucmV0dXJuVmFsdWUgPT09IGZhbHNlIDpcXG4gICAgICAgICAgc291cmNlLmdldFByZXZlbnREZWZhdWx0ICYmIHNvdXJjZS5nZXRQcmV2ZW50RGVmYXVsdCgpKVxcbiAgICAgICAgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZVxcbiAgICB9XFxuICAgIHJldHVybiBldmVudFxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY3JlYXRlUHJveHkoZXZlbnQpIHtcXG4gICAgdmFyIGtleSwgcHJveHkgPSB7IG9yaWdpbmFsRXZlbnQ6IGV2ZW50IH1cXG4gICAgZm9yIChrZXkgaW4gZXZlbnQpXFxuICAgICAgaWYgKCFpZ25vcmVQcm9wZXJ0aWVzLnRlc3Qoa2V5KSAmJiBldmVudFtrZXldICE9PSB1bmRlZmluZWQpIHByb3h5W2tleV0gPSBldmVudFtrZXldXFxuXFxuICAgIHJldHVybiBjb21wYXRpYmxlKHByb3h5LCBldmVudClcXG4gIH1cXG5cXG4gICQuZm4uZGVsZWdhdGUgPSBmdW5jdGlvbihzZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKXtcXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjaylcXG4gIH1cXG4gICQuZm4udW5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjaylcXG4gIH1cXG5cXG4gICQuZm4ubGl2ZSA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XFxuICAgICQoZG9jdW1lbnQuYm9keSkuZGVsZWdhdGUodGhpcy5zZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKVxcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcbiAgJC5mbi5kaWUgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xcbiAgICAkKGRvY3VtZW50LmJvZHkpLnVuZGVsZWdhdGUodGhpcy5zZWxlY3RvciwgZXZlbnQsIGNhbGxiYWNrKVxcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgJC5mbi5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2ssIG9uZSl7XFxuICAgIHZhciBhdXRvUmVtb3ZlLCBkZWxlZ2F0b3IsICR0aGlzID0gdGhpc1xcbiAgICBpZiAoZXZlbnQgJiYgIWlzU3RyaW5nKGV2ZW50KSkge1xcbiAgICAgICQuZWFjaChldmVudCwgZnVuY3Rpb24odHlwZSwgZm4pe1xcbiAgICAgICAgJHRoaXMub24odHlwZSwgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUpXFxuICAgICAgfSlcXG4gICAgICByZXR1cm4gJHRoaXNcXG4gICAgfVxcblxcbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxcbiAgICAgIGNhbGxiYWNrID0gZGF0YSwgZGF0YSA9IHNlbGVjdG9yLCBzZWxlY3RvciA9IHVuZGVmaW5lZFxcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBmYWxzZSlcXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSB1bmRlZmluZWRcXG5cXG4gICAgaWYgKGNhbGxiYWNrID09PSBmYWxzZSkgY2FsbGJhY2sgPSByZXR1cm5GYWxzZVxcblxcbiAgICByZXR1cm4gJHRoaXMuZWFjaChmdW5jdGlvbihfLCBlbGVtZW50KXtcXG4gICAgICBpZiAob25lKSBhdXRvUmVtb3ZlID0gZnVuY3Rpb24oZSl7XFxuICAgICAgICByZW1vdmUoZWxlbWVudCwgZS50eXBlLCBjYWxsYmFjaylcXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpXFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzZWxlY3RvcikgZGVsZWdhdG9yID0gZnVuY3Rpb24oZSl7XFxuICAgICAgICB2YXIgZXZ0LCBtYXRjaCA9ICQoZS50YXJnZXQpLmNsb3Nlc3Qoc2VsZWN0b3IsIGVsZW1lbnQpLmdldCgwKVxcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoICE9PSBlbGVtZW50KSB7XFxuICAgICAgICAgIGV2dCA9ICQuZXh0ZW5kKGNyZWF0ZVByb3h5KGUpLCB7Y3VycmVudFRhcmdldDogbWF0Y2gsIGxpdmVGaXJlZDogZWxlbWVudH0pXFxuICAgICAgICAgIHJldHVybiAoYXV0b1JlbW92ZSB8fCBjYWxsYmFjaykuYXBwbHkobWF0Y2gsIFtldnRdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBhZGQoZWxlbWVudCwgZXZlbnQsIGNhbGxiYWNrLCBkYXRhLCBzZWxlY3RvciwgZGVsZWdhdG9yIHx8IGF1dG9SZW1vdmUpXFxuICAgIH0pXFxuICB9XFxuICAkLmZuLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgY2FsbGJhY2spe1xcbiAgICB2YXIgJHRoaXMgPSB0aGlzXFxuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XFxuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XFxuICAgICAgICAkdGhpcy5vZmYodHlwZSwgc2VsZWN0b3IsIGZuKVxcbiAgICAgIH0pXFxuICAgICAgcmV0dXJuICR0aGlzXFxuICAgIH1cXG5cXG4gICAgaWYgKCFpc1N0cmluZyhzZWxlY3RvcikgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrICE9PSBmYWxzZSlcXG4gICAgICBjYWxsYmFjayA9IHNlbGVjdG9yLCBzZWxlY3RvciA9IHVuZGVmaW5lZFxcblxcbiAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSBjYWxsYmFjayA9IHJldHVybkZhbHNlXFxuXFxuICAgIHJldHVybiAkdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XFxuICAgICAgcmVtb3ZlKHRoaXMsIGV2ZW50LCBjYWxsYmFjaywgc2VsZWN0b3IpXFxuICAgIH0pXFxuICB9XFxuXFxuICAkLmZuLnRyaWdnZXIgPSBmdW5jdGlvbihldmVudCwgYXJncyl7XFxuICAgIGV2ZW50ID0gKGlzU3RyaW5nKGV2ZW50KSB8fCAkLmlzUGxhaW5PYmplY3QoZXZlbnQpKSA/ICQuRXZlbnQoZXZlbnQpIDogY29tcGF0aWJsZShldmVudClcXG4gICAgZXZlbnQuX2FyZ3MgPSBhcmdzXFxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAvLyBoYW5kbGUgZm9jdXMoKSwgYmx1cigpIGJ5IGNhbGxpbmcgdGhlbSBkaXJlY3RseVxcbiAgICAgIGlmIChldmVudC50eXBlIGluIGZvY3VzICYmIHR5cGVvZiB0aGlzW2V2ZW50LnR5cGVdID09IFxcXCJmdW5jdGlvblxcXCIpIHRoaXNbZXZlbnQudHlwZV0oKVxcbiAgICAgIC8vIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG1pZ2h0IG5vdCBiZSBET00gZWxlbWVudHNcXG4gICAgICBlbHNlIGlmICgnZGlzcGF0Y2hFdmVudCcgaW4gdGhpcykgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KVxcbiAgICAgIGVsc2UgJCh0aGlzKS50cmlnZ2VySGFuZGxlcihldmVudCwgYXJncylcXG4gICAgfSlcXG4gIH1cXG5cXG4gIC8vIHRyaWdnZXJzIGV2ZW50IGhhbmRsZXJzIG9uIGN1cnJlbnQgZWxlbWVudCBqdXN0IGFzIGlmIGFuIGV2ZW50IG9jY3VycmVkLFxcbiAgLy8gZG9lc24ndCB0cmlnZ2VyIGFuIGFjdHVhbCBldmVudCwgZG9lc24ndCBidWJibGVcXG4gICQuZm4udHJpZ2dlckhhbmRsZXIgPSBmdW5jdGlvbihldmVudCwgYXJncyl7XFxuICAgIHZhciBlLCByZXN1bHRcXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xcbiAgICAgIGUgPSBjcmVhdGVQcm94eShpc1N0cmluZyhldmVudCkgPyAkLkV2ZW50KGV2ZW50KSA6IGV2ZW50KVxcbiAgICAgIGUuX2FyZ3MgPSBhcmdzXFxuICAgICAgZS50YXJnZXQgPSBlbGVtZW50XFxuICAgICAgJC5lYWNoKGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudC50eXBlIHx8IGV2ZW50KSwgZnVuY3Rpb24oaSwgaGFuZGxlcil7XFxuICAgICAgICByZXN1bHQgPSBoYW5kbGVyLnByb3h5KGUpXFxuICAgICAgICBpZiAoZS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSByZXR1cm4gZmFsc2VcXG4gICAgICB9KVxcbiAgICB9KVxcbiAgICByZXR1cm4gcmVzdWx0XFxuICB9XFxuXFxuICAvLyBzaG9ydGN1dCBtZXRob2RzIGZvciBgLmJpbmQoZXZlbnQsIGZuKWAgZm9yIGVhY2ggZXZlbnQgdHlwZVxcbiAgOygnZm9jdXNpbiBmb2N1c291dCBmb2N1cyBibHVyIGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgJytcXG4gICdtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSAnK1xcbiAgJ2NoYW5nZSBzZWxlY3Qga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBlcnJvcicpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbihldmVudCkge1xcbiAgICAkLmZuW2V2ZW50XSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XFxuICAgICAgcmV0dXJuICgwIGluIGFyZ3VtZW50cykgP1xcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50LCBjYWxsYmFjaykgOlxcbiAgICAgICAgdGhpcy50cmlnZ2VyKGV2ZW50KVxcbiAgICB9XFxuICB9KVxcblxcbiAgJC5FdmVudCA9IGZ1bmN0aW9uKHR5cGUsIHByb3BzKSB7XFxuICAgIGlmICghaXNTdHJpbmcodHlwZSkpIHByb3BzID0gdHlwZSwgdHlwZSA9IHByb3BzLnR5cGVcXG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoc3BlY2lhbEV2ZW50c1t0eXBlXSB8fCAnRXZlbnRzJyksIGJ1YmJsZXMgPSB0cnVlXFxuICAgIGlmIChwcm9wcykgZm9yICh2YXIgbmFtZSBpbiBwcm9wcykgKG5hbWUgPT0gJ2J1YmJsZXMnKSA/IChidWJibGVzID0gISFwcm9wc1tuYW1lXSkgOiAoZXZlbnRbbmFtZV0gPSBwcm9wc1tuYW1lXSlcXG4gICAgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIGJ1YmJsZXMsIHRydWUpXFxuICAgIHJldHVybiBjb21wYXRpYmxlKGV2ZW50KVxcbiAgfVxcblxcbn0pKFplcHRvKVxcblxcbjsoZnVuY3Rpb24oJCl7XFxuICB2YXIganNvbnBJRCA9ICtuZXcgRGF0ZSgpLFxcbiAgICAgIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LFxcbiAgICAgIGtleSxcXG4gICAgICBuYW1lLFxcbiAgICAgIHJzY3JpcHQgPSAvPHNjcmlwdFxcXFxiW148XSooPzooPyE8XFxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcXFwvc2NyaXB0Pi9naSxcXG4gICAgICBzY3JpcHRUeXBlUkUgPSAvXig/OnRleHR8YXBwbGljYXRpb24pXFxcXC9qYXZhc2NyaXB0L2ksXFxuICAgICAgeG1sVHlwZVJFID0gL14oPzp0ZXh0fGFwcGxpY2F0aW9uKVxcXFwveG1sL2ksXFxuICAgICAganNvblR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXFxuICAgICAgaHRtbFR5cGUgPSAndGV4dC9odG1sJyxcXG4gICAgICBibGFua1JFID0gL15cXFxccyokLyxcXG4gICAgICBvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcXG5cXG4gIG9yaWdpbkFuY2hvci5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcXG5cXG4gIC8vIHRyaWdnZXIgYSBjdXN0b20gZXZlbnQgYW5kIHJldHVybiBmYWxzZSBpZiBpdCB3YXMgY2FuY2VsbGVkXFxuICBmdW5jdGlvbiB0cmlnZ2VyQW5kUmV0dXJuKGNvbnRleHQsIGV2ZW50TmFtZSwgZGF0YSkge1xcbiAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50TmFtZSlcXG4gICAgJChjb250ZXh0KS50cmlnZ2VyKGV2ZW50LCBkYXRhKVxcbiAgICByZXR1cm4gIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpXFxuICB9XFxuXFxuICAvLyB0cmlnZ2VyIGFuIEFqYXggXFxcImdsb2JhbFxcXCIgZXZlbnRcXG4gIGZ1bmN0aW9uIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsIGV2ZW50TmFtZSwgZGF0YSkge1xcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsKSByZXR1cm4gdHJpZ2dlckFuZFJldHVybihjb250ZXh0IHx8IGRvY3VtZW50LCBldmVudE5hbWUsIGRhdGEpXFxuICB9XFxuXFxuICAvLyBOdW1iZXIgb2YgYWN0aXZlIEFqYXggcmVxdWVzdHNcXG4gICQuYWN0aXZlID0gMFxcblxcbiAgZnVuY3Rpb24gYWpheFN0YXJ0KHNldHRpbmdzKSB7XFxuICAgIGlmIChzZXR0aW5ncy5nbG9iYWwgJiYgJC5hY3RpdmUrKyA9PT0gMCkgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgbnVsbCwgJ2FqYXhTdGFydCcpXFxuICB9XFxuICBmdW5jdGlvbiBhamF4U3RvcChzZXR0aW5ncykge1xcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsICYmICEoLS0kLmFjdGl2ZSkpIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIG51bGwsICdhamF4U3RvcCcpXFxuICB9XFxuXFxuICAvLyB0cmlnZ2VycyBhbiBleHRyYSBnbG9iYWwgZXZlbnQgXFxcImFqYXhCZWZvcmVTZW5kXFxcIiB0aGF0J3MgbGlrZSBcXFwiYWpheFNlbmRcXFwiIGJ1dCBjYW5jZWxhYmxlXFxuICBmdW5jdGlvbiBhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSB7XFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxcbiAgICBpZiAoc2V0dGluZ3MuYmVmb3JlU2VuZC5jYWxsKGNvbnRleHQsIHhociwgc2V0dGluZ3MpID09PSBmYWxzZSB8fFxcbiAgICAgICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhCZWZvcmVTZW5kJywgW3hociwgc2V0dGluZ3NdKSA9PT0gZmFsc2UpXFxuICAgICAgcmV0dXJuIGZhbHNlXFxuXFxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4U2VuZCcsIFt4aHIsIHNldHRpbmdzXSlcXG4gIH1cXG4gIGZ1bmN0aW9uIGFqYXhTdWNjZXNzKGRhdGEsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKSB7XFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCwgc3RhdHVzID0gJ3N1Y2Nlc3MnXFxuICAgIHNldHRpbmdzLnN1Y2Nlc3MuY2FsbChjb250ZXh0LCBkYXRhLCBzdGF0dXMsIHhocilcXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5yZXNvbHZlV2l0aChjb250ZXh0LCBbZGF0YSwgc3RhdHVzLCB4aHJdKVxcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheFN1Y2Nlc3MnLCBbeGhyLCBzZXR0aW5ncywgZGF0YV0pXFxuICAgIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpXFxuICB9XFxuICAvLyB0eXBlOiBcXFwidGltZW91dFxcXCIsIFxcXCJlcnJvclxcXCIsIFxcXCJhYm9ydFxcXCIsIFxcXCJwYXJzZXJlcnJvclxcXCJcXG4gIGZ1bmN0aW9uIGFqYXhFcnJvcihlcnJvciwgdHlwZSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcXG4gICAgdmFyIGNvbnRleHQgPSBzZXR0aW5ncy5jb250ZXh0XFxuICAgIHNldHRpbmdzLmVycm9yLmNhbGwoY29udGV4dCwgeGhyLCB0eXBlLCBlcnJvcilcXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5yZWplY3RXaXRoKGNvbnRleHQsIFt4aHIsIHR5cGUsIGVycm9yXSlcXG4gICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhFcnJvcicsIFt4aHIsIHNldHRpbmdzLCBlcnJvciB8fCB0eXBlXSlcXG4gICAgYWpheENvbXBsZXRlKHR5cGUsIHhociwgc2V0dGluZ3MpXFxuICB9XFxuICAvLyBzdGF0dXM6IFxcXCJzdWNjZXNzXFxcIiwgXFxcIm5vdG1vZGlmaWVkXFxcIiwgXFxcImVycm9yXFxcIiwgXFxcInRpbWVvdXRcXFwiLCBcXFwiYWJvcnRcXFwiLCBcXFwicGFyc2VyZXJyb3JcXFwiXFxuICBmdW5jdGlvbiBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKSB7XFxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxcbiAgICBzZXR0aW5ncy5jb21wbGV0ZS5jYWxsKGNvbnRleHQsIHhociwgc3RhdHVzKVxcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheENvbXBsZXRlJywgW3hociwgc2V0dGluZ3NdKVxcbiAgICBhamF4U3RvcChzZXR0aW5ncylcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGFqYXhEYXRhRmlsdGVyKGRhdGEsIHR5cGUsIHNldHRpbmdzKSB7XFxuICAgIGlmIChzZXR0aW5ncy5kYXRhRmlsdGVyID09IGVtcHR5KSByZXR1cm4gZGF0YVxcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcXG4gICAgcmV0dXJuIHNldHRpbmdzLmRhdGFGaWx0ZXIuY2FsbChjb250ZXh0LCBkYXRhLCB0eXBlKVxcbiAgfVxcblxcbiAgLy8gRW1wdHkgZnVuY3Rpb24sIHVzZWQgYXMgZGVmYXVsdCBjYWxsYmFja1xcbiAgZnVuY3Rpb24gZW1wdHkoKSB7fVxcblxcbiAgJC5hamF4SlNPTlAgPSBmdW5jdGlvbihvcHRpb25zLCBkZWZlcnJlZCl7XFxuICAgIGlmICghKCd0eXBlJyBpbiBvcHRpb25zKSkgcmV0dXJuICQuYWpheChvcHRpb25zKVxcblxcbiAgICB2YXIgX2NhbGxiYWNrTmFtZSA9IG9wdGlvbnMuanNvbnBDYWxsYmFjayxcXG4gICAgICBjYWxsYmFja05hbWUgPSAoJC5pc0Z1bmN0aW9uKF9jYWxsYmFja05hbWUpID9cXG4gICAgICAgIF9jYWxsYmFja05hbWUoKSA6IF9jYWxsYmFja05hbWUpIHx8ICgnWmVwdG8nICsgKGpzb25wSUQrKykpLFxcbiAgICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxcbiAgICAgIG9yaWdpbmFsQ2FsbGJhY2sgPSB3aW5kb3dbY2FsbGJhY2tOYW1lXSxcXG4gICAgICByZXNwb25zZURhdGEsXFxuICAgICAgYWJvcnQgPSBmdW5jdGlvbihlcnJvclR5cGUpIHtcXG4gICAgICAgICQoc2NyaXB0KS50cmlnZ2VySGFuZGxlcignZXJyb3InLCBlcnJvclR5cGUgfHwgJ2Fib3J0JylcXG4gICAgICB9LFxcbiAgICAgIHhociA9IHsgYWJvcnQ6IGFib3J0IH0sIGFib3J0VGltZW91dFxcblxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnByb21pc2UoeGhyKVxcblxcbiAgICAkKHNjcmlwdCkub24oJ2xvYWQgZXJyb3InLCBmdW5jdGlvbihlLCBlcnJvclR5cGUpe1xcbiAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXFxuICAgICAgJChzY3JpcHQpLm9mZigpLnJlbW92ZSgpXFxuXFxuICAgICAgaWYgKGUudHlwZSA9PSAnZXJyb3InIHx8ICFyZXNwb25zZURhdGEpIHtcXG4gICAgICAgIGFqYXhFcnJvcihudWxsLCBlcnJvclR5cGUgfHwgJ2Vycm9yJywgeGhyLCBvcHRpb25zLCBkZWZlcnJlZClcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgYWpheFN1Y2Nlc3MocmVzcG9uc2VEYXRhWzBdLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxcbiAgICAgIH1cXG5cXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG9yaWdpbmFsQ2FsbGJhY2tcXG4gICAgICBpZiAocmVzcG9uc2VEYXRhICYmICQuaXNGdW5jdGlvbihvcmlnaW5hbENhbGxiYWNrKSlcXG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2socmVzcG9uc2VEYXRhWzBdKVxcblxcbiAgICAgIG9yaWdpbmFsQ2FsbGJhY2sgPSByZXNwb25zZURhdGEgPSB1bmRlZmluZWRcXG4gICAgfSlcXG5cXG4gICAgaWYgKGFqYXhCZWZvcmVTZW5kKHhociwgb3B0aW9ucykgPT09IGZhbHNlKSB7XFxuICAgICAgYWJvcnQoJ2Fib3J0JylcXG4gICAgICByZXR1cm4geGhyXFxuICAgIH1cXG5cXG4gICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbigpe1xcbiAgICAgIHJlc3BvbnNlRGF0YSA9IGFyZ3VtZW50c1xcbiAgICB9XFxuXFxuICAgIHNjcmlwdC5zcmMgPSBvcHRpb25zLnVybC5yZXBsYWNlKC9cXFxcPyguKyk9XFxcXD8vLCAnPyQxPScgKyBjYWxsYmFja05hbWUpXFxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KVxcblxcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xcbiAgICAgIGFib3J0KCd0aW1lb3V0JylcXG4gICAgfSwgb3B0aW9ucy50aW1lb3V0KVxcblxcbiAgICByZXR1cm4geGhyXFxuICB9XFxuXFxuICAkLmFqYXhTZXR0aW5ncyA9IHtcXG4gICAgLy8gRGVmYXVsdCB0eXBlIG9mIHJlcXVlc3RcXG4gICAgdHlwZTogJ0dFVCcsXFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgYmVmb3JlIHJlcXVlc3RcXG4gICAgYmVmb3JlU2VuZDogZW1wdHksXFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHNcXG4gICAgc3VjY2VzczogZW1wdHksXFxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgdGhlIHRoZSBzZXJ2ZXIgZHJvcHMgZXJyb3JcXG4gICAgZXJyb3I6IGVtcHR5LFxcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIG9uIHJlcXVlc3QgY29tcGxldGUgKGJvdGg6IGVycm9yIGFuZCBzdWNjZXNzKVxcbiAgICBjb21wbGV0ZTogZW1wdHksXFxuICAgIC8vIFRoZSBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzXFxuICAgIGNvbnRleHQ6IG51bGwsXFxuICAgIC8vIFdoZXRoZXIgdG8gdHJpZ2dlciBcXFwiZ2xvYmFsXFxcIiBBamF4IGV2ZW50c1xcbiAgICBnbG9iYWw6IHRydWUsXFxuICAgIC8vIFRyYW5zcG9ydFxcbiAgICB4aHI6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpXFxuICAgIH0sXFxuICAgIC8vIE1JTUUgdHlwZXMgbWFwcGluZ1xcbiAgICAvLyBJSVMgcmV0dXJucyBKYXZhc2NyaXB0IGFzIFxcXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcXFwiXFxuICAgIGFjY2VwdHM6IHtcXG4gICAgICBzY3JpcHQ6ICd0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCcsXFxuICAgICAganNvbjogICBqc29uVHlwZSxcXG4gICAgICB4bWw6ICAgICdhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sJyxcXG4gICAgICBodG1sOiAgIGh0bWxUeXBlLFxcbiAgICAgIHRleHQ6ICAgJ3RleHQvcGxhaW4nXFxuICAgIH0sXFxuICAgIC8vIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgdG8gYW5vdGhlciBkb21haW5cXG4gICAgY3Jvc3NEb21haW46IGZhbHNlLFxcbiAgICAvLyBEZWZhdWx0IHRpbWVvdXRcXG4gICAgdGltZW91dDogMCxcXG4gICAgLy8gV2hldGhlciBkYXRhIHNob3VsZCBiZSBzZXJpYWxpemVkIHRvIHN0cmluZ1xcbiAgICBwcm9jZXNzRGF0YTogdHJ1ZSxcXG4gICAgLy8gV2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYmUgYWxsb3dlZCB0byBjYWNoZSBHRVQgcmVzcG9uc2VzXFxuICAgIGNhY2hlOiB0cnVlLFxcbiAgICAvL1VzZWQgdG8gaGFuZGxlIHRoZSByYXcgcmVzcG9uc2UgZGF0YSBvZiBYTUxIdHRwUmVxdWVzdC5cXG4gICAgLy9UaGlzIGlzIGEgcHJlLWZpbHRlcmluZyBmdW5jdGlvbiB0byBzYW5pdGl6ZSB0aGUgcmVzcG9uc2UuXFxuICAgIC8vVGhlIHNhbml0aXplZCByZXNwb25zZSBzaG91bGQgYmUgcmV0dXJuZWRcXG4gICAgZGF0YUZpbHRlcjogZW1wdHlcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG1pbWVUb0RhdGFUeXBlKG1pbWUpIHtcXG4gICAgaWYgKG1pbWUpIG1pbWUgPSBtaW1lLnNwbGl0KCc7JywgMilbMF1cXG4gICAgcmV0dXJuIG1pbWUgJiYgKCBtaW1lID09IGh0bWxUeXBlID8gJ2h0bWwnIDpcXG4gICAgICBtaW1lID09IGpzb25UeXBlID8gJ2pzb24nIDpcXG4gICAgICBzY3JpcHRUeXBlUkUudGVzdChtaW1lKSA/ICdzY3JpcHQnIDpcXG4gICAgICB4bWxUeXBlUkUudGVzdChtaW1lKSAmJiAneG1sJyApIHx8ICd0ZXh0J1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYXBwZW5kUXVlcnkodXJsLCBxdWVyeSkge1xcbiAgICBpZiAocXVlcnkgPT0gJycpIHJldHVybiB1cmxcXG4gICAgcmV0dXJuICh1cmwgKyAnJicgKyBxdWVyeSkucmVwbGFjZSgvWyY/XXsxLDJ9LywgJz8nKVxcbiAgfVxcblxcbiAgLy8gc2VyaWFsaXplIHBheWxvYWQgYW5kIGFwcGVuZCBpdCB0byB0aGUgVVJMIGZvciBHRVQgcmVxdWVzdHNcXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGEob3B0aW9ucykge1xcbiAgICBpZiAob3B0aW9ucy5wcm9jZXNzRGF0YSAmJiBvcHRpb25zLmRhdGEgJiYgJC50eXBlKG9wdGlvbnMuZGF0YSkgIT0gXFxcInN0cmluZ1xcXCIpXFxuICAgICAgb3B0aW9ucy5kYXRhID0gJC5wYXJhbShvcHRpb25zLmRhdGEsIG9wdGlvbnMudHJhZGl0aW9uYWwpXFxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgKCFvcHRpb25zLnR5cGUgfHwgb3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkgPT0gJ0dFVCcgfHwgJ2pzb25wJyA9PSBvcHRpb25zLmRhdGFUeXBlKSlcXG4gICAgICBvcHRpb25zLnVybCA9IGFwcGVuZFF1ZXJ5KG9wdGlvbnMudXJsLCBvcHRpb25zLmRhdGEpLCBvcHRpb25zLmRhdGEgPSB1bmRlZmluZWRcXG4gIH1cXG5cXG4gICQuYWpheCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xcbiAgICB2YXIgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgb3B0aW9ucyB8fCB7fSksXFxuICAgICAgICBkZWZlcnJlZCA9ICQuRGVmZXJyZWQgJiYgJC5EZWZlcnJlZCgpLFxcbiAgICAgICAgdXJsQW5jaG9yLCBoYXNoSW5kZXhcXG4gICAgZm9yIChrZXkgaW4gJC5hamF4U2V0dGluZ3MpIGlmIChzZXR0aW5nc1trZXldID09PSB1bmRlZmluZWQpIHNldHRpbmdzW2tleV0gPSAkLmFqYXhTZXR0aW5nc1trZXldXFxuXFxuICAgIGFqYXhTdGFydChzZXR0aW5ncylcXG5cXG4gICAgaWYgKCFzZXR0aW5ncy5jcm9zc0RvbWFpbikge1xcbiAgICAgIHVybEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxcbiAgICAgIHVybEFuY2hvci5ocmVmID0gc2V0dGluZ3MudXJsXFxuICAgICAgLy8gY2xlYW5zIHVwIFVSTCBmb3IgLmhyZWYgKElFIG9ubHkpLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21hZHJvYmJ5L3plcHRvL3B1bGwvMTA0OVxcbiAgICAgIHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWZcXG4gICAgICBzZXR0aW5ncy5jcm9zc0RvbWFpbiA9IChvcmlnaW5BbmNob3IucHJvdG9jb2wgKyAnLy8nICsgb3JpZ2luQW5jaG9yLmhvc3QpICE9PSAodXJsQW5jaG9yLnByb3RvY29sICsgJy8vJyArIHVybEFuY2hvci5ob3N0KVxcbiAgICB9XFxuXFxuICAgIGlmICghc2V0dGluZ3MudXJsKSBzZXR0aW5ncy51cmwgPSB3aW5kb3cubG9jYXRpb24udG9TdHJpbmcoKVxcbiAgICBpZiAoKGhhc2hJbmRleCA9IHNldHRpbmdzLnVybC5pbmRleE9mKCcjJykpID4gLTEpIHNldHRpbmdzLnVybCA9IHNldHRpbmdzLnVybC5zbGljZSgwLCBoYXNoSW5kZXgpXFxuICAgIHNlcmlhbGl6ZURhdGEoc2V0dGluZ3MpXFxuXFxuICAgIHZhciBkYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlLCBoYXNQbGFjZWhvbGRlciA9IC9cXFxcPy4rPVxcXFw/Ly50ZXN0KHNldHRpbmdzLnVybClcXG4gICAgaWYgKGhhc1BsYWNlaG9sZGVyKSBkYXRhVHlwZSA9ICdqc29ucCdcXG5cXG4gICAgaWYgKHNldHRpbmdzLmNhY2hlID09PSBmYWxzZSB8fCAoXFxuICAgICAgICAgKCFvcHRpb25zIHx8IG9wdGlvbnMuY2FjaGUgIT09IHRydWUpICYmXFxuICAgICAgICAgKCdzY3JpcHQnID09IGRhdGFUeXBlIHx8ICdqc29ucCcgPT0gZGF0YVR5cGUpXFxuICAgICAgICApKVxcbiAgICAgIHNldHRpbmdzLnVybCA9IGFwcGVuZFF1ZXJ5KHNldHRpbmdzLnVybCwgJ189JyArIERhdGUubm93KCkpXFxuXFxuICAgIGlmICgnanNvbnAnID09IGRhdGFUeXBlKSB7XFxuICAgICAgaWYgKCFoYXNQbGFjZWhvbGRlcilcXG4gICAgICAgIHNldHRpbmdzLnVybCA9IGFwcGVuZFF1ZXJ5KHNldHRpbmdzLnVybCxcXG4gICAgICAgICAgc2V0dGluZ3MuanNvbnAgPyAoc2V0dGluZ3MuanNvbnAgKyAnPT8nKSA6IHNldHRpbmdzLmpzb25wID09PSBmYWxzZSA/ICcnIDogJ2NhbGxiYWNrPT8nKVxcbiAgICAgIHJldHVybiAkLmFqYXhKU09OUChzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgIH1cXG5cXG4gICAgdmFyIG1pbWUgPSBzZXR0aW5ncy5hY2NlcHRzW2RhdGFUeXBlXSxcXG4gICAgICAgIGhlYWRlcnMgPSB7IH0sXFxuICAgICAgICBzZXRIZWFkZXIgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkgeyBoZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV0gPSBbbmFtZSwgdmFsdWVdIH0sXFxuICAgICAgICBwcm90b2NvbCA9IC9eKFtcXFxcdy1dKzopXFxcXC9cXFxcLy8udGVzdChzZXR0aW5ncy51cmwpID8gUmVnRXhwLiQxIDogd2luZG93LmxvY2F0aW9uLnByb3RvY29sLFxcbiAgICAgICAgeGhyID0gc2V0dGluZ3MueGhyKCksXFxuICAgICAgICBuYXRpdmVTZXRIZWFkZXIgPSB4aHIuc2V0UmVxdWVzdEhlYWRlcixcXG4gICAgICAgIGFib3J0VGltZW91dFxcblxcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnByb21pc2UoeGhyKVxcblxcbiAgICBpZiAoIXNldHRpbmdzLmNyb3NzRG9tYWluKSBzZXRIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKVxcbiAgICBzZXRIZWFkZXIoJ0FjY2VwdCcsIG1pbWUgfHwgJyovKicpXFxuICAgIGlmIChtaW1lID0gc2V0dGluZ3MubWltZVR5cGUgfHwgbWltZSkge1xcbiAgICAgIGlmIChtaW1lLmluZGV4T2YoJywnKSA+IC0xKSBtaW1lID0gbWltZS5zcGxpdCgnLCcsIDIpWzBdXFxuICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZSlcXG4gICAgfVxcbiAgICBpZiAoc2V0dGluZ3MuY29udGVudFR5cGUgfHwgKHNldHRpbmdzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSAmJiBzZXR0aW5ncy5kYXRhICYmIHNldHRpbmdzLnR5cGUudG9VcHBlckNhc2UoKSAhPSAnR0VUJykpXFxuICAgICAgc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBzZXR0aW5ncy5jb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJylcXG5cXG4gICAgaWYgKHNldHRpbmdzLmhlYWRlcnMpIGZvciAobmFtZSBpbiBzZXR0aW5ncy5oZWFkZXJzKSBzZXRIZWFkZXIobmFtZSwgc2V0dGluZ3MuaGVhZGVyc1tuYW1lXSlcXG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIgPSBzZXRIZWFkZXJcXG5cXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XFxuICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eVxcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dClcXG4gICAgICAgIHZhciByZXN1bHQsIGVycm9yID0gZmFsc2VcXG4gICAgICAgIGlmICgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PSAzMDQgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiBwcm90b2NvbCA9PSAnZmlsZTonKSkge1xcbiAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IG1pbWVUb0RhdGFUeXBlKHNldHRpbmdzLm1pbWVUeXBlIHx8IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykpXFxuXFxuICAgICAgICAgIGlmICh4aHIucmVzcG9uc2VUeXBlID09ICdhcnJheWJ1ZmZlcicgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PSAnYmxvYicpXFxuICAgICAgICAgICAgcmVzdWx0ID0geGhyLnJlc3BvbnNlXFxuICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHJlc3VsdCA9IHhoci5yZXNwb25zZVRleHRcXG5cXG4gICAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vZ2xvYmFsLWV2YWwtd2hhdC1hcmUtdGhlLW9wdGlvbnMvXFxuICAgICAgICAgICAgICAvLyBzYW5pdGl6ZSByZXNwb25zZSBhY2NvcmRpbmdseSBpZiBkYXRhIGZpbHRlciBjYWxsYmFjayBwcm92aWRlZFxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gYWpheERhdGFGaWx0ZXIocmVzdWx0LCBkYXRhVHlwZSwgc2V0dGluZ3MpXFxuICAgICAgICAgICAgICBpZiAoZGF0YVR5cGUgPT0gJ3NjcmlwdCcpICAgICgxLGV2YWwpKHJlc3VsdClcXG4gICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFUeXBlID09ICd4bWwnKSAgcmVzdWx0ID0geGhyLnJlc3BvbnNlWE1MXFxuICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAnanNvbicpIHJlc3VsdCA9IGJsYW5rUkUudGVzdChyZXN1bHQpID8gbnVsbCA6ICQucGFyc2VKU09OKHJlc3VsdClcXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IGVycm9yID0gZSB9XFxuXFxuICAgICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gYWpheEVycm9yKGVycm9yLCAncGFyc2VyZXJyb3InLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBhamF4U3VjY2VzcyhyZXN1bHQsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgYWpheEVycm9yKHhoci5zdGF0dXNUZXh0IHx8IG51bGwsIHhoci5zdGF0dXMgPyAnZXJyb3InIDogJ2Fib3J0JywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UpIHtcXG4gICAgICB4aHIuYWJvcnQoKVxcbiAgICAgIGFqYXhFcnJvcihudWxsLCAnYWJvcnQnLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICByZXR1cm4geGhyXFxuICAgIH1cXG5cXG4gICAgdmFyIGFzeW5jID0gJ2FzeW5jJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLmFzeW5jIDogdHJ1ZVxcbiAgICB4aHIub3BlbihzZXR0aW5ncy50eXBlLCBzZXR0aW5ncy51cmwsIGFzeW5jLCBzZXR0aW5ncy51c2VybmFtZSwgc2V0dGluZ3MucGFzc3dvcmQpXFxuXFxuICAgIGlmIChzZXR0aW5ncy54aHJGaWVsZHMpIGZvciAobmFtZSBpbiBzZXR0aW5ncy54aHJGaWVsZHMpIHhocltuYW1lXSA9IHNldHRpbmdzLnhockZpZWxkc1tuYW1lXVxcblxcbiAgICBmb3IgKG5hbWUgaW4gaGVhZGVycykgbmF0aXZlU2V0SGVhZGVyLmFwcGx5KHhociwgaGVhZGVyc1tuYW1lXSlcXG5cXG4gICAgaWYgKHNldHRpbmdzLnRpbWVvdXQgPiAwKSBhYm9ydFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XFxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHlcXG4gICAgICAgIHhoci5hYm9ydCgpXFxuICAgICAgICBhamF4RXJyb3IobnVsbCwgJ3RpbWVvdXQnLCB4aHIsIHNldHRpbmdzLCBkZWZlcnJlZClcXG4gICAgICB9LCBzZXR0aW5ncy50aW1lb3V0KVxcblxcbiAgICAvLyBhdm9pZCBzZW5kaW5nIGVtcHR5IHN0cmluZyAoIzMxOSlcXG4gICAgeGhyLnNlbmQoc2V0dGluZ3MuZGF0YSA/IHNldHRpbmdzLmRhdGEgOiBudWxsKVxcbiAgICByZXR1cm4geGhyXFxuICB9XFxuXFxuICAvLyBoYW5kbGUgb3B0aW9uYWwgZGF0YS9zdWNjZXNzIGFyZ3VtZW50c1xcbiAgZnVuY3Rpb24gcGFyc2VBcmd1bWVudHModXJsLCBkYXRhLCBzdWNjZXNzLCBkYXRhVHlwZSkge1xcbiAgICBpZiAoJC5pc0Z1bmN0aW9uKGRhdGEpKSBkYXRhVHlwZSA9IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSBkYXRhLCBkYXRhID0gdW5kZWZpbmVkXFxuICAgIGlmICghJC5pc0Z1bmN0aW9uKHN1Y2Nlc3MpKSBkYXRhVHlwZSA9IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSB1bmRlZmluZWRcXG4gICAgcmV0dXJuIHtcXG4gICAgICB1cmw6IHVybFxcbiAgICAsIGRhdGE6IGRhdGFcXG4gICAgLCBzdWNjZXNzOiBzdWNjZXNzXFxuICAgICwgZGF0YVR5cGU6IGRhdGFUeXBlXFxuICAgIH1cXG4gIH1cXG5cXG4gICQuZ2V0ID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzLCBkYXRhVHlwZSAqLyl7XFxuICAgIHJldHVybiAkLmFqYXgocGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSlcXG4gIH1cXG5cXG4gICQucG9zdCA9IGZ1bmN0aW9uKC8qIHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUgKi8pe1xcbiAgICB2YXIgb3B0aW9ucyA9IHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcXG4gICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnXFxuICAgIHJldHVybiAkLmFqYXgob3B0aW9ucylcXG4gIH1cXG5cXG4gICQuZ2V0SlNPTiA9IGZ1bmN0aW9uKC8qIHVybCwgZGF0YSwgc3VjY2VzcyAqLyl7XFxuICAgIHZhciBvcHRpb25zID0gcGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxcbiAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2pzb24nXFxuICAgIHJldHVybiAkLmFqYXgob3B0aW9ucylcXG4gIH1cXG5cXG4gICQuZm4ubG9hZCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgc3VjY2Vzcyl7XFxuICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVybiB0aGlzXFxuICAgIHZhciBzZWxmID0gdGhpcywgcGFydHMgPSB1cmwuc3BsaXQoL1xcXFxzLyksIHNlbGVjdG9yLFxcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlQXJndW1lbnRzKHVybCwgZGF0YSwgc3VjY2VzcyksXFxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnMuc3VjY2Vzc1xcbiAgICBpZiAocGFydHMubGVuZ3RoID4gMSkgb3B0aW9ucy51cmwgPSBwYXJ0c1swXSwgc2VsZWN0b3IgPSBwYXJ0c1sxXVxcbiAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwb25zZSl7XFxuICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID9cXG4gICAgICAgICQoJzxkaXY+JykuaHRtbChyZXNwb25zZS5yZXBsYWNlKHJzY3JpcHQsIFxcXCJcXFwiKSkuZmluZChzZWxlY3RvcilcXG4gICAgICAgIDogcmVzcG9uc2UpXFxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suYXBwbHkoc2VsZiwgYXJndW1lbnRzKVxcbiAgICB9XFxuICAgICQuYWpheChvcHRpb25zKVxcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgdmFyIGVzY2FwZSA9IGVuY29kZVVSSUNvbXBvbmVudFxcblxcbiAgZnVuY3Rpb24gc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbCwgc2NvcGUpe1xcbiAgICB2YXIgdHlwZSwgYXJyYXkgPSAkLmlzQXJyYXkob2JqKSwgaGFzaCA9ICQuaXNQbGFpbk9iamVjdChvYmopXFxuICAgICQuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgICB0eXBlID0gJC50eXBlKHZhbHVlKVxcbiAgICAgIGlmIChzY29wZSkga2V5ID0gdHJhZGl0aW9uYWwgPyBzY29wZSA6XFxuICAgICAgICBzY29wZSArICdbJyArIChoYXNoIHx8IHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnYXJyYXknID8ga2V5IDogJycpICsgJ10nXFxuICAgICAgLy8gaGFuZGxlIGRhdGEgaW4gc2VyaWFsaXplQXJyYXkoKSBmb3JtYXRcXG4gICAgICBpZiAoIXNjb3BlICYmIGFycmF5KSBwYXJhbXMuYWRkKHZhbHVlLm5hbWUsIHZhbHVlLnZhbHVlKVxcbiAgICAgIC8vIHJlY3Vyc2UgaW50byBuZXN0ZWQgb2JqZWN0c1xcbiAgICAgIGVsc2UgaWYgKHR5cGUgPT0gXFxcImFycmF5XFxcIiB8fCAoIXRyYWRpdGlvbmFsICYmIHR5cGUgPT0gXFxcIm9iamVjdFxcXCIpKVxcbiAgICAgICAgc2VyaWFsaXplKHBhcmFtcywgdmFsdWUsIHRyYWRpdGlvbmFsLCBrZXkpXFxuICAgICAgZWxzZSBwYXJhbXMuYWRkKGtleSwgdmFsdWUpXFxuICAgIH0pXFxuICB9XFxuXFxuICAkLnBhcmFtID0gZnVuY3Rpb24ob2JqLCB0cmFkaXRpb25hbCl7XFxuICAgIHZhciBwYXJhbXMgPSBbXVxcbiAgICBwYXJhbXMuYWRkID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24odmFsdWUpKSB2YWx1ZSA9IHZhbHVlKClcXG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSBcXFwiXFxcIlxcbiAgICAgIHRoaXMucHVzaChlc2NhcGUoa2V5KSArICc9JyArIGVzY2FwZSh2YWx1ZSkpXFxuICAgIH1cXG4gICAgc2VyaWFsaXplKHBhcmFtcywgb2JqLCB0cmFkaXRpb25hbClcXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJylcXG4gIH1cXG59KShaZXB0bylcXG5cXG47KGZ1bmN0aW9uKCQpe1xcbiAgJC5mbi5zZXJpYWxpemVBcnJheSA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgbmFtZSwgdHlwZSwgcmVzdWx0ID0gW10sXFxuICAgICAgYWRkID0gZnVuY3Rpb24odmFsdWUpIHtcXG4gICAgICAgIGlmICh2YWx1ZS5mb3JFYWNoKSByZXR1cm4gdmFsdWUuZm9yRWFjaChhZGQpXFxuICAgICAgICByZXN1bHQucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KVxcbiAgICAgIH1cXG4gICAgaWYgKHRoaXNbMF0pICQuZWFjaCh0aGlzWzBdLmVsZW1lbnRzLCBmdW5jdGlvbihfLCBmaWVsZCl7XFxuICAgICAgdHlwZSA9IGZpZWxkLnR5cGUsIG5hbWUgPSBmaWVsZC5uYW1lXFxuICAgICAgaWYgKG5hbWUgJiYgZmllbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSAnZmllbGRzZXQnICYmXFxuICAgICAgICAhZmllbGQuZGlzYWJsZWQgJiYgdHlwZSAhPSAnc3VibWl0JyAmJiB0eXBlICE9ICdyZXNldCcgJiYgdHlwZSAhPSAnYnV0dG9uJyAmJiB0eXBlICE9ICdmaWxlJyAmJlxcbiAgICAgICAgKCh0eXBlICE9ICdyYWRpbycgJiYgdHlwZSAhPSAnY2hlY2tib3gnKSB8fCBmaWVsZC5jaGVja2VkKSlcXG4gICAgICAgICAgYWRkKCQoZmllbGQpLnZhbCgpKVxcbiAgICB9KVxcbiAgICByZXR1cm4gcmVzdWx0XFxuICB9XFxuXFxuICAkLmZuLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCl7XFxuICAgIHZhciByZXN1bHQgPSBbXVxcbiAgICB0aGlzLnNlcmlhbGl6ZUFycmF5KCkuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xcbiAgICAgIHJlc3VsdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChlbG0ubmFtZSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZWxtLnZhbHVlKSlcXG4gICAgfSlcXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcXG4gIH1cXG5cXG4gICQuZm4uc3VibWl0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcXG4gICAgaWYgKDAgaW4gYXJndW1lbnRzKSB0aGlzLmJpbmQoJ3N1Ym1pdCcsIGNhbGxiYWNrKVxcbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aCkge1xcbiAgICAgIHZhciBldmVudCA9ICQuRXZlbnQoJ3N1Ym1pdCcpXFxuICAgICAgdGhpcy5lcSgwKS50cmlnZ2VyKGV2ZW50KVxcbiAgICAgIGlmICghZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHRoaXMuZ2V0KDApLnN1Ym1pdCgpXFxuICAgIH1cXG4gICAgcmV0dXJuIHRoaXNcXG4gIH1cXG5cXG59KShaZXB0bylcXG5cXG47KGZ1bmN0aW9uKCl7XFxuICAvLyBnZXRDb21wdXRlZFN0eWxlIHNob3VsZG4ndCBmcmVhayBvdXQgd2hlbiBjYWxsZWRcXG4gIC8vIHdpdGhvdXQgYSB2YWxpZCBlbGVtZW50IGFzIGFyZ3VtZW50XFxuICB0cnkge1xcbiAgICBnZXRDb21wdXRlZFN0eWxlKHVuZGVmaW5lZClcXG4gIH0gY2F0Y2goZSkge1xcbiAgICB2YXIgbmF0aXZlR2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGVcXG4gICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUgPSBmdW5jdGlvbihlbGVtZW50LCBwc2V1ZG9FbGVtZW50KXtcXG4gICAgICB0cnkge1xcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgcHNldWRvRWxlbWVudClcXG4gICAgICB9IGNhdGNoKGUpIHtcXG4gICAgICAgIHJldHVybiBudWxsXFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxufSkoKVxcbiAgcmV0dXJuIFplcHRvXFxufSkpXFxuXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},,,,,,,,,,,,,function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(18), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzPzgwMzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLFlBQVksbUJBQU8sQ0FBQyxFQUFtQyIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(19);\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzP2EyMWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLEVBQXFCO0FBQ3hDLHVDQUF1Qyw0QkFBNEI7QUFDbkUseUNBQXlDO0FBQ3pDO0FBQ0EiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY29yZSA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKTtcbnZhciAkSlNPTiA9IGNvcmUuSlNPTiB8fCAoY29yZS5KU09OID0geyBzdHJpbmdpZnk6IEpTT04uc3RyaW5naWZ5IH0pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICByZXR1cm4gJEpTT04uc3RyaW5naWZ5LmFwcGx5KCRKU09OLCBhcmd1bWVudHMpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval("var core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvcmUuanM/NTg0YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw2QkFBNkI7QUFDN0IsdUNBQXVDIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNS43JyB9O1xuaWYgKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpIF9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n")}]]);